import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,o as s,c as d,b as e,e as l,a as n,d as a}from"./app-CgPki5_t.js";const o={},h=a('<h1 id="个人经验总结" tabindex="-1"><a class="header-anchor" href="#个人经验总结"><span>个人经验总结</span></a></h1><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span><em>基础</em></span></a></h2><h3 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-6.png" alt=""></p><h3 id="强转" tabindex="-1"><a class="header-anchor" href="#强转"><span>强转</span></a></h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-7.png" alt=""></p><h3 id="访问修饰符" tabindex="-1"><a class="header-anchor" href="#访问修饰符"><span>访问修饰符</span></a></h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-12.png" alt=""></p><h3 id="final-关键字" tabindex="-1"><a class="header-anchor" href="#final-关键字"><span>final 关键字</span></a></h3><ul><li>被 final 修饰的类不可以被继承 <ul><li>String 类被 final 关键字修饰</li></ul></li><li>被 final 修饰的方法不可以被重写</li><li>被 final 修饰的变量不可变，被 final 修饰的变量必须被显式第指定初始值，还得注意的是，这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变。</li></ul><h3 id="integer小知识" tabindex="-1"><a class="header-anchor" href="#integer小知识"><span>Integer小知识:</span></a></h3>',11),c={href:"https://mp.weixin.qq.com/s/mBs5k2LnoGMerpE2vAQzyg",target:"_blank",rel:"noopener noreferrer"},u=e("mark",null,"1000为false而100",-1),p=a(`<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Integer a = 1000, b = 1000;  
System.out.println(a == b);
Integer c = 100, d = 100;  
System.out.println(c == d);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>false
true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,2),E=e("h3",{id:"nio-和-io-区别",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#nio-和-io-区别"},[e("span",null,"NIO 和 IO 区别")])],-1),_=e("ul",null,[e("li",null,"NIO 是非阻塞的"),e("li",null,"NIO 面向块，I/O 面向流")],-1),m=e("h2",{id:"spring",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#spring"},[e("span",null,[e("em",null,"Spring")])])],-1),g={id:"spring-boot-生命周期",tabindex:"-1"},b={class:"header-anchor",href:"#spring-boot-生命周期"},v={href:"https://blog.csdn.net/f641385712/article/details/105762050",target:"_blank",rel:"noopener noreferrer"},f=a(`<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>ApplicationStartingEvent：开始启动中
ApplicationEnvironmentPreparedEvent：环境已准备好
ApplicationContextInitializedEvent：上下文已实例化
ApplicationPreparedEvent：上下文已准备好
ApplicationStartedEvent：应用成功启动
ApplicationReadyEvent：应用已准备好
ApplicationFailedEvent：应用启动失败
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="获取上下文方式" tabindex="-1"><a class="header-anchor" href="#获取上下文方式"><span>获取上下文方式：</span></a></h3>`,2),B={href:"https://hutool.cn/docs/#/extra/Spring/Spring%E5%B7%A5%E5%85%B7-SpringUtil",target:"_blank",rel:"noopener noreferrer"},A={href:"https://github.com/yuanmabiji/Java-SourceCode-Blogs/blob/master/SpringBoot/10%20SpringBoot%E5%86%85%E7%BD%AE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%20%20SpringBoot%E6%BA%90%E7%A0%81(%E5%8D%81).md",target:"_blank",rel:"noopener noreferrer"},k={href:"https://docsify.tobebetterjavaer.com/#/docs/sidebar/sanfene/spring",target:"_blank",rel:"noopener noreferrer"},x=e("h2",{id:"mysql",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mysql"},[e("span",null,[e("em",null,"Mysql")])])],-1),w={id:"存储引擎",tabindex:"-1"},S={class:"header-anchor",href:"#存储引擎"},T={href:"https://www.pdai.tech/md/db/sql-mysql/sql-mysql-engine.html#mysql---%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E",target:"_blank",rel:"noopener noreferrer"},R=a("<ul><li>InnoDB <ul><li>事务型存储引擎</li><li>四个标准隔离级别</li><li>主索引是聚簇索引</li><li>支持真正的在线热备份</li><li>支持表跟行级锁</li><li>支持外键</li></ul></li><li>MyISAM <ul><li>不支持事务</li><li>不支持行级锁</li><li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</li><li>其它特性: MyISAM 支持压缩表和空间数据索引</li></ul></li></ul>",1),C={id:"sql-优化",tabindex:"-1"},I={class:"header-anchor",href:"#sql-优化"},F={href:"https://www.pdai.tech/md/db/sql-lan/sql-lan-optimize.html#sql%E8%AF%AD%E8%A8%80---sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96",target:"_blank",rel:"noopener noreferrer"},q=e("h2",{id:"redis",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#redis"},[e("span",null,[e("em",null,"Redis")])])],-1),D=e("h3",{id:"分布式锁",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#分布式锁"},[e("span",null,"分布式锁")])],-1),O=e("li",null,[l('这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，'),e("br"),l(" 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。")],-1),P=e("li",null,[l("实现 "),e("ul",null,[e("li",null,"单个Redis实例：setnx(key,当前时间+过期时间) + Lua"),e("li",null,"Redis集群模式：Redlock")])],-1),y=e("li",null,"借助 Redis 实现分布式锁时，有一个共同的缺陷: 当获取锁被拒绝后，需要不断的循环，重新发送获取锁(创建 key )的请求，直到请求成功。这就造成空转，浪费宝贵的 CPU 资源。",-1),M={href:"https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html",target:"_blank",rel:"noopener noreferrer"},z={href:"http://antirez.com/news/101",target:"_blank",rel:"noopener noreferrer"},N=a(`<h3 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存"><span>缓存</span></a></h3><ul><li>缓存穿透 <ul><li>缓存穿透是指缓存和数据库中都没有的数据</li><li>解决： <ul><li>接口层增加校验</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null</li><li>布隆过滤器</li></ul></li></ul></li><li>缓存击穿 <ul><li>缓存击穿是指缓存中没有但数据库中有的数据(一般是缓存时间到期)</li><li>解决： <ul><li>设置热点数据永远不过期</li><li>接口限流与熔断，降级</li><li>加互斥锁</li></ul></li></ul></li><li>缓存雪崩 <ul><li>缓存雪崩是指缓存中数据大批量到过期时间</li><li>解决： <ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中</li><li>设置热点数据永远不过期</li></ul></li></ul></li><li>用途</li></ul><h2 id="mq" tabindex="-1"><a class="header-anchor" href="#mq"><span><em>MQ</em></span></a></h2><h3 id="集群高可用部署" tabindex="-1"><a class="header-anchor" href="#集群高可用部署"><span>集群高可用部署</span></a></h3><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span><em>事务</em></span></a></h2><h3 id="分布事务" tabindex="-1"><a class="header-anchor" href="#分布事务"><span>分布事务</span></a></h3><ul><li>Seata <ul><li>TC (Transaction Coordinator) - 事务协调者 <ul><li>维护全局和分支事务的状态，指示全局提交或者回滚。</li></ul></li><li>TM (Transaction Manager) - 事务管理器 <ul><li>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li></ul></li><li>RM (Resource Manager) - 资源管理器 <ul><li>管理执行分支事务的那些资源，向 TC 注册分支事务、上报分支事务状态、控制分支事务的提交或者回滚。</li></ul></li><li>TM是一个分布式事务的发起者和终结者(管理者)，TC 负责维护分布式事务的运行状态，而 RM 则负责本地事务的运行。三个组件相互协作，其中 TC 以 Server 形式独立部署，TM 和 RM 集成在应用中启动</li></ul></li></ul><h3 id="spring事务" tabindex="-1"><a class="header-anchor" href="#spring事务"><span>Spring事务</span></a></h3><ul><li>传播机制<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>PROPAGATION_REQUIRED —— 支持当前事务，如果当前没有事务，则新建一个事务，这是最常见的选择，也是 Spring 默认的一个事务传播属性。
PROPAGATION_SUPPORTS —— 支持当前事务，如果当前没有事务，则以非事务方式执行。
PROPAGATION_MANDATORY —— 支持当前事务，如果当前没有事务，则抛出异常。
PROPAGATION_REQUIRES_NEW —— 新建事务，如果当前存在事务，把当前事务挂起。
PROPAGATION_NOT_SUPPORTED —— 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER —— 以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED —— Nested 的事务和它的父事务是相依的，它的提交是要等和它的父事务一块提交的。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>四大特性：原子性、一致性、隔离性、持久性</li><li>隔离级别：<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
未提交读 (read uncommited) :脏读，不可重复读，虚读都有可能发生
已提交读 (read commited):避免脏读。但是不可重复读和虚读有可能发生
可重复读 (repeatable read) :避免脏读和不可重复读.但是虚读有可能发生.
串行化的 (serializable) :避免以上所有读问题.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>可能引起失效原因： <ul><li>@Transactional 应用在非 public 修饰的方法上</li><li>@Transactional 注解属性 propagation(传播机制) 设置错误</li><li>@Transactional 注解属性 rollbackFor 设置错误</li><li>同一个类中方法调用，导致@Transactional 失效</li></ul></li></ul><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span><em>设计模式</em></span></a></h2><h3 id="spring中应用的设计模式" tabindex="-1"><a class="header-anchor" href="#spring中应用的设计模式"><span>Spring中应用的设计模式</span></a></h3><ul><li>工厂模式 <ul><li>Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li></ul></li><li>代理模式 <ul><li>Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</li></ul></li><li>单例模式 <ul><li>Spring 中的 Bean 默认都是单例的，这样有利于容器对 Bean 的管理。</li></ul></li><li>模板模式 <ul><li>Spring 中 JdbcTemplate、RestTemplate 等以 Template 结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。</li></ul></li><li>观察者模式 <ul><li>Spring 事件驱动模型就是观察者模式很经典的一个应用。</li></ul></li><li>适配器模式 <ul><li>Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</li></ul></li><li>策略模式 <ul><li>Spring 中有一个 Resource 接口，它的不同实现类，会根据不同的策略去访问资源。</li></ul></li></ul><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程"><span><em>多线程</em></span></a></h2><h3 id="线程使用方式" tabindex="-1"><a class="header-anchor" href="#线程使用方式"><span>线程使用方式</span></a></h3><ul><li>实现 Runnable 接口 <ul><li>需要实现 run() 方法。</li><li>通过 Thread 调用 start() 方法来启动线程。</li></ul></li><li>实现 Callable 接口 <ul><li>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</li></ul></li><li>继承 Thread 类 <ul><li>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</li><li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li></ul></li></ul>`,15),j={id:"threadlocal",tabindex:"-1"},L={class:"header-anchor",href:"#threadlocal"},U={href:"https://www.pdai.tech/md/java/thread/java-thread-x-threadlocal.html#java-%E5%B9%B6%E5%8F%91---threadlocal%E8%AF%A6%E8%A7%A3",target:"_blank",rel:"noopener noreferrer"},G=e("ul",null,[e("li",null,"ThreadLocal是通过线程隔离的方式防止任务在共享资源上产生冲突, 线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储")],-1),Q=e("h2",{id:"分布式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#分布式"},[e("span",null,[e("em",null,"分布式")])])],-1),J=e("h3",{id:"跨服务之间分页查询实现及大量数据导出情况",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#跨服务之间分页查询实现及大量数据导出情况"},[e("span",null,"跨服务之间分页查询实现及大量数据导出情况")])],-1),V=e("ul",null,[e("li",null,"个人实际经历是针对当前服务为主体进行查询，遍历获取对应的 id，然后 RPC 调用其它服务通过 id 去获取数据集合，再对其进行封装。"),e("li",null,"针对导出需要查询大量数据的情况，则是采取服务端生成形式。")],-1),H={id:"分库分表实现",tabindex:"-1"},W={class:"header-anchor",href:"#分库分表实现"},Y={href:"https://www.pdai.tech/md/framework/ds-sharding/sharding-x-arch.html",target:"_blank",rel:"noopener noreferrer"},Z={id:"分布式锁实现",tabindex:"-1"},K={class:"header-anchor",href:"#分布式锁实现"},X={href:"https://www.pdai.tech/md/arch/arch-z-lock.html#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F---%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88",target:"_blank",rel:"noopener noreferrer"},$={href:"https://www.pdai.tech/md/arch/arch-z-lock.html#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7",target:"_blank",rel:"noopener noreferrer"},ee={href:"https://www.pdai.tech/md/arch/arch-z-lock.html#%E5%9F%BA%E4%BA%8Eredis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7",target:"_blank",rel:"noopener noreferrer"},le=e("ul",null,[e("li",null,"参照上面Redis知识整理")],-1),ie={href:"https://www.pdai.tech/md/arch/arch-z-lock.html#%E5%9F%BA%E4%BA%8Ezookeeper%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81",target:"_blank",rel:"noopener noreferrer"},ne={id:"分布式-id-实现",tabindex:"-1"},ae={class:"header-anchor",href:"#分布式-id-实现"},te={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id",target:"_blank",rel:"noopener noreferrer"},re={href:"https://www.pdai.tech/md/arch/arch-z-id.html#uuid",target:"_blank",rel:"noopener noreferrer"},se={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90",target:"_blank",rel:"noopener noreferrer"},de={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E4%BD%BF%E7%94%A8redis%E5%AE%9E%E7%8E%B0",target:"_blank",rel:"noopener noreferrer"},oe={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95-snowflake",target:"_blank",rel:"noopener noreferrer"},he={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E7%99%BE%E5%BA%A6-uidgenerator",target:"_blank",rel:"noopener noreferrer"},ce={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E7%BE%8E%E5%9B%A2leaf",target:"_blank",rel:"noopener noreferrer"},ue={href:"https://www.pdai.tech/md/arch/arch-z-id.html#mist-%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},pe={id:"微服务组件",tabindex:"-1"},Ee={class:"header-anchor",href:"#微服务组件"},_e={href:"https://www.pdai.tech/md/interview/x-interview-2.html#141-spring-cloud",target:"_blank",rel:"noopener noreferrer"},me={href:"https://www.pdai.tech/md/arch/arch-z-overview.html",target:"_blank",rel:"noopener noreferrer"},ge=e("h2",{id:"高并发",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#高并发"},[e("span",null,[e("em",null,"高并发")])])],-1),be={id:"接口幂等性",tabindex:"-1"},ve={class:"header-anchor",href:"#接口幂等性"},fe={href:"https://www.pdai.tech/md/spring/springboot/springboot-x-interface-mideng.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89",target:"_blank",rel:"noopener noreferrer"},Be=a('<ul><li>从幂等和防止重复提交，接口幂等和常见的保证幂等的方式等知识点构筑知识体系 <ul><li>幂等: 更多的是在重复请求已经发生，或是无法避免的情况下，采取一定的技术手段让这些重复请求不给系统带来副作用</li><li>防止重复提交: 更多的是不让用户发起多次一样的请求,主要还是从客户端的角度来解决这个问题</li></ul></li><li>保证幂等方式 <ul><li>数据库层面 <ul><li>悲观锁: for update</li></ul></li><li>唯一 ID/索引</li><li>乐观锁 <ul><li>使用版本号或者时间戳</li><li>状态机</li></ul></li></ul></li><li>分布式锁</li></ul><h2 id="其它" tabindex="-1"><a class="header-anchor" href="#其它"><span><em>其它</em></span></a></h2>',2),Ae={id:"秒杀系统",tabindex:"-1"},ke={class:"header-anchor",href:"#秒杀系统"},xe={href:"https://www.pdai.tech/md/arch/arch-example-seckill.html#%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B---%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1",target:"_blank",rel:"noopener noreferrer"},we=e("ul",null,[e("li",null,"遇到的印象最深的问题，如何解决"),e("li",null,"常用中间件实现原理")],-1),Se={id:"前后端分离接口安全",tabindex:"-1"},Te={class:"header-anchor",href:"#前后端分离接口安全"},Re={href:"https://www.pdai.tech/md/spring/springboot/springboot-x-interface-jiami.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"};function Ce(Ie,Fe){const i=r("ExternalLinkIcon");return s(),d("div",null,[h,e("ul",null,[e("li",null,[e("p",null,[e("a",c,[l("涉及IntegerCache，1000"),u,l("100为true"),n(i)]),l(":")]),p])]),E,_,m,e("h3",g,[e("a",b,[e("span",null,[e("a",v,[l("Spring boot 生命周期"),n(i)])])])]),f,e("ul",null,[e("li",null,[e("a",B,[l("实现ApplicationContextAware"),n(i)])])]),e("p",null,[e("a",A,[l("SpringBoot内置生命周期事件详解"),n(i)])]),e("p",null,[e("a",k,[l("Spring：35道精选面试题"),n(i)])]),x,e("h3",w,[e("a",S,[e("span",null,[e("a",T,[l("存储引擎"),n(i)])])])]),R,e("h3",C,[e("a",I,[e("span",null,[e("a",F,[l("SQL 优化"),n(i)])])])]),q,D,e("ul",null,[O,P,e("li",null,[l("缺点 "),e("ul",null,[y,e("li",null,[l("RedLock算法本身有争议，具体看这篇文章 "),e("a",M,[l("How to do distributed locking"),n(i)]),l(" (opens new window) 以及作者的回复 "),e("a",z,[l("Is Redlock safe?"),n(i)])])])])]),N,e("h3",j,[e("a",L,[e("span",null,[e("a",U,[l("ThreadLocal"),n(i)])])])]),G,Q,J,V,e("h3",H,[e("a",W,[e("span",null,[e("a",Y,[l("分库分表实现"),n(i)])])])]),e("h3",Z,[e("a",K,[e("span",null,[e("a",X,[l("分布式锁实现"),n(i)])])])]),e("ul",null,[e("li",null,[e("a",$,[l("基于数据库"),n(i)])]),e("li",null,[e("a",ee,[l("基于 Redis"),n(i)]),le]),e("li",null,[e("a",ie,[l("基于 zookeeper"),n(i)])])]),e("h3",ne,[e("a",ae,[e("span",null,[e("a",te,[l("分布式 ID 实现"),n(i)])])])]),e("ul",null,[e("li",null,[l("全局唯一ID "),e("ul",null,[e("li",null,[e("a",re,[l("UUID"),n(i)])]),e("li",null,[e("a",se,[l("数据库生成"),n(i)])]),e("li",null,[e("a",de,[l("使用redis实现"),n(i)])]),e("li",null,[e("a",oe,[l("雪花算法-Snowflake"),n(i)])]),e("li",null,[e("a",he,[l("百度-UidGenerator"),n(i)])]),e("li",null,[e("a",ce,[l("美团Leaf"),n(i)])]),e("li",null,[e("a",ue,[l("Mist 薄雾算法"),n(i)])])])])]),e("h3",pe,[e("a",Ee,[e("span",null,[e("a",_e,[l("微服务组件"),n(i)])])])]),e("p",null,[e("a",me,[l("分布式系统知识体系"),n(i)])]),ge,e("h3",be,[e("a",ve,[e("span",null,[e("a",fe,[l("接口幂等性"),n(i)])])])]),Be,e("h3",Ae,[e("a",ke,[e("span",null,[e("a",xe,[l("秒杀系统"),n(i)])])])]),we,e("h3",Se,[e("a",Te,[e("span",null,[e("a",Re,[l("前后端分离接口安全"),n(i)])])])])])}const Oe=t(o,[["render",Ce],["__file","interview.html.vue"]]),Pe=JSON.parse('{"path":"/posts/interview/interview.html","title":"个人经验总结","lang":"zh-CN","frontmatter":{"icon":"lock","date":"2022-05-13T00:00:00.000Z","category":["面试"],"tag":["Java","Spring","Redis","MQ","MySql","分布式"],"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"基础","slug":"基础","link":"#基础","children":[{"level":3,"title":"数据类型","slug":"数据类型","link":"#数据类型","children":[]},{"level":3,"title":"强转","slug":"强转","link":"#强转","children":[]},{"level":3,"title":"访问修饰符","slug":"访问修饰符","link":"#访问修饰符","children":[]},{"level":3,"title":"final 关键字","slug":"final-关键字","link":"#final-关键字","children":[]},{"level":3,"title":"Integer小知识:","slug":"integer小知识","link":"#integer小知识","children":[]},{"level":3,"title":"NIO 和 IO 区别","slug":"nio-和-io-区别","link":"#nio-和-io-区别","children":[]}]},{"level":2,"title":"Spring","slug":"spring","link":"#spring","children":[{"level":3,"title":"Spring boot 生命周期","slug":"spring-boot-生命周期","link":"#spring-boot-生命周期","children":[]},{"level":3,"title":"获取上下文方式：","slug":"获取上下文方式","link":"#获取上下文方式","children":[]}]},{"level":2,"title":"Mysql","slug":"mysql","link":"#mysql","children":[{"level":3,"title":"存储引擎","slug":"存储引擎","link":"#存储引擎","children":[]},{"level":3,"title":"SQL 优化","slug":"sql-优化","link":"#sql-优化","children":[]}]},{"level":2,"title":"Redis","slug":"redis","link":"#redis","children":[{"level":3,"title":"分布式锁","slug":"分布式锁","link":"#分布式锁","children":[]},{"level":3,"title":"缓存","slug":"缓存","link":"#缓存","children":[]}]},{"level":2,"title":"MQ","slug":"mq","link":"#mq","children":[{"level":3,"title":"集群高可用部署","slug":"集群高可用部署","link":"#集群高可用部署","children":[]}]},{"level":2,"title":"事务","slug":"事务","link":"#事务","children":[{"level":3,"title":"分布事务","slug":"分布事务","link":"#分布事务","children":[]},{"level":3,"title":"Spring事务","slug":"spring事务","link":"#spring事务","children":[]}]},{"level":2,"title":"设计模式","slug":"设计模式","link":"#设计模式","children":[{"level":3,"title":"Spring中应用的设计模式","slug":"spring中应用的设计模式","link":"#spring中应用的设计模式","children":[]}]},{"level":2,"title":"多线程","slug":"多线程","link":"#多线程","children":[{"level":3,"title":"线程使用方式","slug":"线程使用方式","link":"#线程使用方式","children":[]},{"level":3,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[]}]},{"level":2,"title":"分布式","slug":"分布式","link":"#分布式","children":[{"level":3,"title":"跨服务之间分页查询实现及大量数据导出情况","slug":"跨服务之间分页查询实现及大量数据导出情况","link":"#跨服务之间分页查询实现及大量数据导出情况","children":[]},{"level":3,"title":"分库分表实现","slug":"分库分表实现","link":"#分库分表实现","children":[]},{"level":3,"title":"分布式锁实现","slug":"分布式锁实现","link":"#分布式锁实现","children":[]},{"level":3,"title":"分布式 ID 实现","slug":"分布式-id-实现","link":"#分布式-id-实现","children":[]},{"level":3,"title":"微服务组件","slug":"微服务组件","link":"#微服务组件","children":[]}]},{"level":2,"title":"高并发","slug":"高并发","link":"#高并发","children":[{"level":3,"title":"接口幂等性","slug":"接口幂等性","link":"#接口幂等性","children":[]}]},{"level":2,"title":"其它","slug":"其它","link":"#其它","children":[{"level":3,"title":"秒杀系统","slug":"秒杀系统","link":"#秒杀系统","children":[]},{"level":3,"title":"前后端分离接口安全","slug":"前后端分离接口安全","link":"#前后端分离接口安全","children":[]}]}],"git":{"createdTime":1653376909000,"updatedTime":1704805150000,"contributors":[{"name":"zJiaC","email":"jc456123","commits":5},{"name":"zJiaC","email":"425226133@qq.com","commits":2}]},"readingTime":{"minutes":9.92,"words":2975},"filePathRelative":"posts/interview/interview.md","localizedDate":"2022年5月13日"}');export{Oe as comp,Pe as data};
