import{_ as r}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o,c,b as a,d as n,e,a as p,f as t}from"./app-9HIzqMwZ.js";const l="/tech-arch-doc/images/单链表.png",d="/tech-arch-doc/images/循环链表.png",u="/tech-arch-doc/images/双向链表.png",h="/tech-arch-doc/images/双向循环链表.png",k="/tech-arch-doc/images/ArrayList、LinkedList，头插结构.png",m="/tech-arch-doc/images/ArrayList、LinkedList，头插对比.png",_="/tech-arch-doc/images/ArrayList、LinkedList，尾插结构.png",b="/tech-arch-doc/images/ArrayList、LinkedList，尾插对比.png",g="/tech-arch-doc/images/ArrayList、LinkedList，中间插结构.png",L="/tech-arch-doc/images/ArrayList、LinkedList，中间插对比.png",y={},v=a("h1",{id:"线性数据结构相关",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#线性数据结构相关","aria-hidden":"true"},"#"),n(" 线性数据结构相关")],-1),A={href:"https://visualgo.net/zh",target:"_blank",rel:"noopener noreferrer"},E=t('<h2 id="链表-link-list" tabindex="-1"><a class="header-anchor" href="#链表-link-list" aria-hidden="true">#</a> 链表 Link List</h2><p>在计算机科学中，链表是数据元素的线性集合，元素的线性顺序不是由它们在内存中的物理地址给出的。它是由一组节点组成的数据结构，每个元素指向下一个元素，这些节点一起，表示线性序列。</p><h3 id="描述一下链表的数据结构" tabindex="-1"><a class="header-anchor" href="#描述一下链表的数据结构" aria-hidden="true">#</a> 描述一下链表的数据结构？</h3><p><img src="'+l+'" alt="单链表"><br><img src="'+d+'" alt="循环链表"><br><img src="'+u+'" alt="双向链表"><br><img src="'+h+'" alt="双向链表"></p><h3 id="java-中-linkedlist-使用的是单向链表、双向链表还是循环链表" tabindex="-1"><a class="header-anchor" href="#java-中-linkedlist-使用的是单向链表、双向链表还是循环链表" aria-hidden="true">#</a> Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？</h3><ul><li>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul><h3 id="链表中数据的插入、删除、获取元素-时间复杂度是多少" tabindex="-1"><a class="header-anchor" href="#链表中数据的插入、删除、获取元素-时间复杂度是多少" aria-hidden="true">#</a> 链表中数据的插入、删除、获取元素，时间复杂度是多少？</h3><ul><li>单向链表要删除某一节点时，必须要先通过遍历的方式找到前驱节点（通过待删除节点序号或按值查找）。若仅仅知道待删除节点，是不能知道前驱节点的，故单链表的增删操作复杂度为O(n)。</li><li>双链表（双向链表）知道要删除某一节点p时，获取其前驱节点q的方式为 q = p-&gt;prior，不必再进行遍历。故时间复杂度为O(1)。而若只知道待删除节点的序号，则依然要按序查找，时间复杂度仍为O(n)。</li><li>单、双链表的插入操作，若给定前驱节点，则时间复杂度均为O(1)。否则只能按序或按值查找前驱节点，时间复杂度为O(n)。</li><li>至于查找，二者的时间复杂度均为O(n)。 对于最基本的CRUD操作，双链表优势在于删除给定节点。但其劣势在于浪费存储空间（若从工程角度考量，则其维护性和可读性都更低）。</li></ul>',8),f=a("br",null,null,-1),C={href:"https://bugstack.cn/md/java/interview/2020-08-30-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C%20%C2%B7%20%E7%AC%AC8%E7%AF%87%E3%80%8ALinkedList%E6%8F%92%E5%85%A5%E9%80%9F%E5%BA%A6%E6%AF%94ArrayList%E5%BF%AB%EF%BC%9F%E4%BD%A0%E7%A1%AE%E5%AE%9A%E5%90%97%EF%BC%9F%E3%80%8B.html",target:"_blank",rel:"noopener noreferrer"},w=t(`<h2 id="数组-array" tabindex="-1"><a class="header-anchor" href="#数组-array" aria-hidden="true">#</a> 数组 Array</h2><p>数组只是个名称，它可以描述一组操作，也可以命名这组操作。数组的数据操作，是通过 idx-&gt;val 的方式来处理。它不是具体要求内存上要存储着连续的数据才叫数组，而是说，通过连续的索引 idx，也可以线性访问相邻的数据。</p><h3 id="数组的元素删除和获取-时间复杂度是多少" tabindex="-1"><a class="header-anchor" href="#数组的元素删除和获取-时间复杂度是多少" aria-hidden="true">#</a> 数组的元素删除和获取，时间复杂度是多少？</h3><ul><li>因为数组的元素在内存中都是连续的，在访问其中元素的时候，会根据元素的下标相对于第一个下标的距离直接访问内存，所以访问任意元素的时间复杂度为O(1)，不与数组下标大小有关联，所以说它的随机存取的速度非常快。改数组其中的元素其实也是访问数组的下标，更改内存地址存放的内容，其复杂度是一样的。</li><li>查的时候说了数组存取非常快，在数组的增加元素的时候，看复杂度的时候要看元素插入的位置。自己在前面文章时候偷懒了，只在Goalng的切片后面加元素，不用动其他的元素，这是最乐观的情况，所以在数组后面添加元素的时候，时间最好复杂度<br> 为O(1)，如果在数组最前面添加元素的话，后面元素在内存中存放的位置都要往后挪一位，此时要操作所有的元素，此时为最坏复杂度<br> ：O(n)，如果要看平均复杂度<br> 的话，那么就要遍历数组插入的所有插入位置的可能，然后把所有的复杂度相加再除以所有的可能的数量，那么假如数组长度为N,复杂度就是（1+2+3+...+n）/n=&gt;n/2,然后忽略常数部分，数组增加元素平均复杂度<br> 就是O(n)</li><li>删除和增加元素一样，删除数组第一个元素，后面所有的元素都要移动内存地址，复杂度为O(n)，删除最后一个元素，就只操作数组中的一个元素，此时复杂度是最好复杂度<br> ：O(1),平均复杂度<br> 为O(n)。</li></ul><h3 id="arraylist-中默认的初始化长度是多少" tabindex="-1"><a class="header-anchor" href="#arraylist-中默认的初始化长度是多少" aria-hidden="true">#</a> ArrayList 中默认的初始化长度是多少？</h3><p>ArrayList 底层是数组 elementData，用于存放插入的数据。初始大小是 0，当有数据插入时，默认大小 DEFAULT_CAPACITY = 10。</p><h3 id="arraylist-中扩容的范围是多大一次" tabindex="-1"><a class="header-anchor" href="#arraylist-中扩容的范围是多大一次" aria-hidden="true">#</a> ArrayList 中扩容的范围是多大一次？</h3><p>新数组容量为旧数组的 1.5 倍：newCapacity = 1.5 * oldCapacity ，并且将旧数组内容通过 Array.copyOf 全部复制到新数组。此时，size 还未真正 +1，新旧数组长度（size 一致），不过容量不同。</p><h3 id="arraylist-是如何完成扩容的-system-arraycopy-各个入参的作用是什么" tabindex="-1"><a class="header-anchor" href="#arraylist-是如何完成扩容的-system-arraycopy-各个入参的作用是什么" aria-hidden="true">#</a> ArrayList 是如何完成扩容的，System.arraycopy 各个入参的作用是什么？</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 确保内部容量</span>
    <span class="token keyword">int</span> minCapacity <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        minCapacity <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 判断扩容操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 添加元素</span>
    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="什么场景下使用数组或链表更合适" tabindex="-1"><a class="header-anchor" href="#什么场景下使用数组或链表更合适" aria-hidden="true">#</a> 什么场景下使用数组或链表更合适？</h2><ul><li>对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线性表。<br><img src="`+k+'" alt=""><br><img src="'+m+'" alt=""><br><img src="'+_+'" alt=""><br><img src="'+b+'" alt=""><br><img src="'+g+'" alt=""><br><img src="'+L+'" alt=""></li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><ul><li>ArrayList与LinkedList都有自己的使用场景，如果你不能很好的确定，那么就使用ArrayList。但如果你能确定你会在集合的首位有大量的插入、删除以及获取操作，那么可以使用LinkedList，因为它都有相应的方法；addFirst、addLast、removeFirst、removeLast、getFirst、getLast，这些操作的时间复杂度都是O(1)，非常高效。</li><li>LinkedList的链表结构不一定会比ArrayList节省空间，首先它所占用的内存不是连续的，其次他还需要大量的实例化对象创造节点。虽然不一定节省空间，但链表结构也是非常优秀的数据结构，它能在你的程序设计中起着非常优秀的作用，例如可视化的链路追踪图，就是需要链表结构，并需要每个节点自旋一次，用于串联业务。</li><li>程序的精髓往往就是数据结构的设计，这能为你的程序开发提供出非常高的效率改变。可能目前你还不能用到，但万一有一天你需要去造🚀火箭了呢？</li></ul><h1 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h1>',15),F={href:"https://bugstack.cn/md/algorithm/data-structures/2022-07-22-linked-list.html",target:"_blank",rel:"noopener noreferrer"},B={href:"https://bugstack.cn/md/algorithm/data-structures/2022-07-22-linked-list.html",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.pdai.tech/md/java/collection/java-collection-LinkedList.html",target:"_blank",rel:"noopener noreferrer"},D={href:"https://blog.csdn.net/weixin_43338519/article/details/107577687",target:"_blank",rel:"noopener noreferrer"},O={href:"https://blog.csdn.net/m0_37135421/article/details/80964378",target:"_blank",rel:"noopener noreferrer"},j={href:"https://bugstack.cn/md/java/interview/2020-08-30-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C%20%C2%B7%20%E7%AC%AC8%E7%AF%87%E3%80%8ALinkedList%E6%8F%92%E5%85%A5%E9%80%9F%E5%BA%A6%E6%AF%94ArrayList%E5%BF%AB%EF%BC%9F%E4%BD%A0%E7%A1%AE%E5%AE%9A%E5%90%97%EF%BC%9F%E3%80%8B.html",target:"_blank",rel:"noopener noreferrer"},T={href:"https://www.modb.pro/db/166034",target:"_blank",rel:"noopener noreferrer"},N={href:"https://www.cnblogs.com/ideal-20/p/14380633.html",target:"_blank",rel:"noopener noreferrer"};function z(I,V){const s=i("ExternalLinkIcon");return o(),c("div",null,[v,a("p",null,[a("a",A,[n("数据结构和算法动态可视化 (Chinese)"),e(s)])]),p(" more "),E,a("p",null,[n("双链表本身的结构优势在于，可以O(1)地找到前驱节点，若算法需要对待操作节点的前驱节点做处理，则双链表相比单链表有更加便捷的优势。"),f,a("a",C,[n("LinkedList插入速度比ArrayList快？你确定吗？"),e(s)])]),w,a("p",null,[a("a",F,[n("数组和链表"),e(s)])]),a("p",null,[a("a",B,[n("数据结构：链表 Link List"),e(s)])]),a("p",null,[a("a",x,[n("java-collection-LinkedList"),e(s)])]),a("p",null,[a("a",D,[n("链表的插入、删除、查找时间复杂度"),e(s)])]),a("p",null,[a("a",O,[n("数组和链表分别比较适合用于什么场景"),e(s)])]),a("p",null,[a("a",j,[n("LinkedList插入速度比ArrayList快？你确定吗？"),e(s)])]),a("p",null,[a("a",T,[n("动态数组和链表的增删改查的时间复杂度对比"),e(s)])]),a("p",null,[a("a",N,[n("Java ArrayList源码分析（含扩容机制等重点问题分析）"),e(s)])])])}const Y=r(y,[["render",z],["__file","linear-data-structures.html.vue"]]);export{Y as default};
