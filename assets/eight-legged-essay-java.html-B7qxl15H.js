import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as h,o as n}from"./app-X9Qm7P3-.js";const e="/tech-arch-doc/images/java-io-byte.png",l="/tech-arch-doc/images/java-io-character.png",r="/tech-arch-doc/images/Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8.jpg",t="/tech-arch-doc/images/hashmap-put-1.7.webp",p="/tech-arch-doc/images/hashmap-put-1.8.webp",d="/tech-arch-doc/images/hashmap-get-1.7.webp",c="/tech-arch-doc/images/hashmap-get-1.8.webp",k={};function o(b,a){return n(),i("div",null,[...a[0]||(a[0]=[h(`<h1 id="java-八股文" tabindex="-1"><a class="header-anchor" href="#java-八股文"><span>Java 八股文</span></a></h1><h2 id="一、java基础-44-道" tabindex="-1"><a class="header-anchor" href="#一、java基础-44-道"><span>一、Java基础 44 道</span></a></h2><h3 id="解释下什么是面向对象-面向对象和面向过程的区别" tabindex="-1"><a class="header-anchor" href="#解释下什么是面向对象-面向对象和面向过程的区别"><span><a href="http://web.suda.edu.cn/hejun/local_csharp/chapter1/csharp_1_3.html#python1" target="_blank" rel="noopener noreferrer">解释下什么是面向对象？面向对象和面向过程的区别？</a></span></a></h3><table><thead><tr><th>项目名称</th><th>面向对象程序设计</th><th>面向过程程序设计（也叫结构化编程）</th></tr></thead><tbody><tr><td>定义</td><td>面向对象顾名思义就是把现实中的事务都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，是一种“自下而上”的设计语言，先设计组件，再完成拼装。</td><td>面向过程是“自上而下”的设计语言，先定好框架，再增砖添瓦。通俗点，就是先定好main()函数，然后再逐步实现mian()函数中所要用到的其他方法。</td></tr><tr><td>特点</td><td>封装、继承、多态</td><td>算法+数据结构</td></tr><tr><td>优势</td><td>适用于大型复杂系统，方便复用、</td><td>适用于简单系统，容易理解</td></tr><tr><td>劣势</td><td>比较抽象、性能比面向过程低</td><td>难以应对复杂系统，难以复用，不易维护、不易扩展</td></tr><tr><td>对比</td><td>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td><td>性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</td></tr><tr><td>设计语言</td><td>Java、Smalltalk、EIFFEL、C++、Objective-、C#、Python等</td><td>C、Fortran</td></tr></tbody></table><h3 id="面向对象的三大特性-分别解释下" tabindex="-1"><a class="header-anchor" href="#面向对象的三大特性-分别解释下"><span><a href="http://web.suda.edu.cn/hejun/local_csharp/chapter1/csharp_1_3.html#python1" target="_blank" rel="noopener noreferrer">面向对象的三大特性？分别解释下？</a></span></a></h3><ul><li><p>封装</p><blockquote><p>两层含义：一层含义是把对象的属性和行为看成一个密不可分的整体，将这两者“封装”在一个不可分割的独立单元(即对象)中；<br> 另一层含义指“信息隐藏”，把不需要让外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改，<br> 而另一些属性或行为，则不允许外界知晓，或只允许使用对象的功能，而尽可能隐藏对象的功能实现细节。</p></blockquote><ul><li>优点 <ul><li>良好的封装能够减少耦合，符合程序设计追求“高内聚，低耦合”。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息实现细节。</li></ul></li></ul></li><li><p>继承</p><blockquote><p>继承是面向对象编程技术的一块基石，因为它允许创建分等级层次的类。<br> 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p></blockquote><ul><li>优点 <ul><li>提高类代码的复用性</li><li>提高了代码的维护性</li><li>使得类和类产生了关系，是多态的前提(它也是继承的一个弊端，类的耦合性提高了)</li></ul></li></ul></li><li><p>多态</p><blockquote><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p></blockquote></li></ul><h3 id="jdk、jre、jvm-三者之间的关系" tabindex="-1"><a class="header-anchor" href="#jdk、jre、jvm-三者之间的关系"><span>JDK、JRE、JVM 三者之间的关系？</span></a></h3><ul><li>JDK（Java Development Kit） <ul><li>是针对Java开发员的产品，是整个Java的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。</li></ul></li><li>JRE（Java Runtime Environment） <ul><li>是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。</li></ul></li><li>JVM（Java Virtual Machine） <ul><li>是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。</li></ul></li></ul><h3 id="重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#重载和重写的区别"><span>重载和重写的区别？</span></a></h3><ul><li>重写(Override) <ul><li>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</li><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li></ul></li><li>重载(Overload) <ul><li>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</li><li>应该注意的是，返回值不同，其它都相同不算是重载。</li></ul></li></ul><h3 id="java-中是否可以重写一个-private-或者-static-方法" tabindex="-1"><a class="header-anchor" href="#java-中是否可以重写一个-private-或者-static-方法"><span>Java 中是否可以重写一个 private 或者 static 方法？</span></a></h3><ul><li>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。</li><li>static 方法类的任何实例都不相关，所以概念上不适用。</li><li>Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。</li></ul><h3 id="构造方法有哪些特性" tabindex="-1"><a class="header-anchor" href="#构造方法有哪些特性"><span>构造方法有哪些特性？</span></a></h3><ul><li>构造方法名一定与类同名。</li><li>构造方法无返回值。</li><li>构造方法可以没有（默认一个无参构造方法），也可以有多个构造方法。他们之间构成重载关系。</li><li>如果定义有参构造函数，则无参构造函数将被自动屏蔽。</li><li>构造方法不能被继承。</li><li>构造方法不能手动调用，在创建类实例的时候自动调用构造方法。</li></ul><h3 id="在-java-中定义一个不做事且没有参数的构造方法有什么作用" tabindex="-1"><a class="header-anchor" href="#在-java-中定义一个不做事且没有参数的构造方法有什么作用"><span>在 Java 中定义一个不做事且没有参数的构造方法有什么作用？</span></a></h3><ul><li>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</li><li>如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误。</li><li>Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</li></ul><h3 id="java-中创建对象的几种方式" tabindex="-1"><a class="header-anchor" href="#java-中创建对象的几种方式"><span>Java 中创建对象的几种方式？</span></a></h3><ul><li>使用 new 关键字：这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的够赞函数（无参的和有参的）。比如：Student student = new Student();</li><li>使用 Class 类的 newInstance 方法：我们也可以使用 Class 类的 newInstance 方法创建对象，这个 newInstance 方法调用无参的构造器创建对象，如：Student student2 = (Student)Class.forName(&quot;根路径.Student&quot;).newInstance();　或者：Student stu = Student.class.newInstance();</li><li>使用 Constructor 类的 newInstance 方法：本方法和 Class 类的 newInstance 方法很像，java.lang.relect.Constructor 类里也有一个 newInstance 方法可以创建对象。我们可以通过这个 newInstance 方法调用有参数的和私有的构造函数。如： Constructor constructor =Student.class.getInstance(); Student stu = constructor.newInstance();　这两种 newInstance 的方法就是大家所说的反射，事实上 Class 的 newInstance 方法内部调用 Constructor 的 newInstance 方法。这也是众多框架 Spring、Hibernate、Struts 等使用后者的原因。</li><li>使用 Clone 的方法：无论何时我们调用一个对象的 clone 方法，JVM 就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用 clone 方法创建对象并不会调用任何构造函数。要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。如：Student stu2 = stu.clone();这也是原型模式的应用。</li><li>使用反序列化：当我们序列化和反序列化一个对象，JVM 会给我们创建一个单独的对象，在反序列化时，JVM 创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现 Serializable 接口。如：ObjectInputStream in = new ObjectInputStream (new FileInputStream(&quot;data.obj&quot;)); Student stu3 = (Student)in.readObject();</li></ul><h3 id="抽象类和接口有什么区别" tabindex="-1"><a class="header-anchor" href="#抽象类和接口有什么区别"><span>抽象类和接口有什么区别？</span></a></h3><ul><li>抽象类中可以定义构造方法，而接口中不可以定义构造方法；</li><li>抽象类中可以有抽象方法和具体方法，而接口中只能有抽象方法（public abstract）；</li><li>抽象类中的成员权限可以是 public、默认（default）、protected（抽象类中的抽象方法就是为了重写，所以不能被 private 修饰），而接口中的成员只可以是 public（方法默认：public abstact，成员变量默认：public static final）；</li><li>抽象类中可以包含静态方法，而接口中不可以包含静态方法。</li></ul><h3 id="静态变量和实例变量的区别" tabindex="-1"><a class="header-anchor" href="#静态变量和实例变量的区别"><span>静态变量和实例变量的区别？</span></a></h3><ul><li>静态变量前要加上关键字 static，实例变量则不会。</li><li>实例变量是属于某个对象的属性，必须创建了实例对象，其中的实例变量才会分配空间，才能使用这个实例变量。</li><li>静态变量不属于任何的实例对象，而是属于类，也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，就会被分配空间。</li><li>静态变量不需要创建任何的对象就可以直接使用，而实例变量需要先创建实例对象才能被使用。</li></ul><h3 id="_12、short-s1-1-s1-s1-1-有什么错-那么-short-s1-1-s1-1-呢-有没有错误" tabindex="-1"><a class="header-anchor" href="#_12、short-s1-1-s1-s1-1-有什么错-那么-short-s1-1-s1-1-呢-有没有错误"><span>12、short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？</span></a></h3><ul><li>对于 short s1 = 1; s1 = s1 + 1; 由于 s1+1 运算时会自动提升表达式的类型，所以结果是 int 型，再赋值给 short 类型 s1 时，编译器将报告需要强制转换类型的错误。</li><li>对于 short s1 = 1; s1 += 1;由于 += 是 java 语言规定的运算符，java 编译器会对它进行特殊处理，因此可以正确编译。</li></ul><h3 id="integer-和-int-的区别" tabindex="-1"><a class="header-anchor" href="#integer-和-int-的区别"><span>Integer 和 int 的区别？</span></a></h3><ul><li>Integer 是 int 的包装类；int 是基本数据类型；</li><li>Integer 变量必须实例化后才能使用；int 变量不需要；</li><li>Integer 实际是对象的引用，指向此 new 的 Integer 对象；int 是直接存储数据值 ；</li><li>Integer 的默认值是 null；int 的默认值是0。</li></ul><h3 id="装箱和拆箱的区别" tabindex="-1"><a class="header-anchor" href="#装箱和拆箱的区别"><span>装箱和拆箱的区别</span></a></h3><ul><li>装箱就是自动将基本数据类型转换为包装器类型</li><li>拆箱就是自动将包装器类型转换为基本数据类型</li></ul><h3 id="switch-语句能否作用在-byte-上-能否作用在-long-上-能否作用在-string-上" tabindex="-1"><a class="header-anchor" href="#switch-语句能否作用在-byte-上-能否作用在-long-上-能否作用在-string-上"><span>switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？</span></a></h3><ul><li>switch 可作用于 char byte short int</li><li>switch 可作用于 char byte short int 对应的包装类</li><li>switch 不可作用于 long double float boolean，包括他们的包装类</li><li>switch 中可以是字符串类型,String(JDK1.7 之后才可以作用在 string 上)</li><li>switch 中可以是枚举类型(JDK1.5 之后)</li></ul><h3 id="final、finally、finalize-的区别" tabindex="-1"><a class="header-anchor" href="#final、finally、finalize-的区别"><span>final、finally、finalize 的区别</span></a></h3><ul><li>final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.</li><li>finally 是异常处理语句结构的一部分，表示总是执行.</li><li>finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.</li></ul><h3 id="和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#和-equals-的区别"><span>== 和 equals 的区别？</span></a></h3><ul><li>对象类型不同 <ul><li>equals()：是超类 Object 中的方法。</li><li>==：是操作符。</li></ul></li><li>比较的对象不同 <ul><li>equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。</li><li>==：用于比较引用和比较基本数据类型时具有不同的功能，具体如下: <ul><li>基础数据类型：比较的是他们的值是否相等，比如两个 int 类型的变量，比较的是变量的值是否一样。</li><li>引用数据类型：比较的是引用的地址是否相同，比如说新建了两个 User 对象，比较的是两个 User 的地址是否一样。</li></ul></li></ul></li><li>运行速度不同 <ul><li>equals()：没有==运行速度快。</li><li>== 运行速度比 equals() 快，因为==只是比较引用。</li></ul></li></ul><h3 id="两个对象的-hashcode-相同-则-equals-也一定为-true-吗" tabindex="-1"><a class="header-anchor" href="#两个对象的-hashcode-相同-则-equals-也一定为-true-吗"><span><a href="https://www.modb.pro/db/105634" target="_blank" rel="noopener noreferrer">两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？</a></span></a></h3><ul><li>Hashcode() 相等，equals() 可能相等，也可能不等。 <ul><li>假如这个类没有重写 equals 方法，如果两个对象值相同(x.equals(y) == true)，那么那么它们的hashCode值一定要相同；</li><li>如果重写 equals 方法，没有重写 HashCode 的方法，就会出现不相等的情况。</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>equals() 方法不相等的两个对象，Hashcode() 有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。<br> 反过来，Hashcode() 不等，一定能推出 equals() 也不等；Hashcode() 相等，equals() 可能相等，也可能不等。</p></div><h3 id="为什么重写-equals-就一定要重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#为什么重写-equals-就一定要重写-hashcode-方法"><span>为什么重写 equals() 就一定要重写 hashCode() 方法？</span></a></h3><ul><li>如果想完整的使用 HashSet 类 那么最少要重写 equals() 和 HashCode() 方法。 <ul><li>重写 HashCode() 用于获得元素的存储位置；</li><li>重写 equals() 用于在两个元素的位置相同的时候 比较两个元素是否相等。</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">原因分析</p><p>HashCode<br> public int hashCode() 返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 Java.util.Hashtable 提供的哈希表）的性能。<br> HashCode 的常规协定是：<br> 在 Java 应用程序执行期间，在对同一对象多次调用 HashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。<br> 如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 HashCode 方法都必须生成相同的整数结果。<br> 如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 HashCode 方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br> 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）</p><p>equals<br> public boolean equals (Object obj) 指示其他某个对象是否与此对象“相等”。<br> equals 方法在非空对象引用上实现相等关系：<br> 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。<br> 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。<br> 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。<br> 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。</p><p>对于任何非空引用值 x，x.equals(null) 都应返回 false。<br> Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。</p></div><h3 id="和-的区别" tabindex="-1"><a class="header-anchor" href="#和-的区别"><span>&amp; 和 &amp;&amp; 的区别？</span></a></h3><ul><li>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。 <ul><li>&amp;&amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式。</li></ul></li><li>&amp;还可以用作按位与的运算符，两个表达式的值按二进制位展开，对应的位 (bit) 按值进行“与”运算，结果保留在该位上</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;<br> 即：两位同时为“1”，结果才为“1”，否则为0<br> 例如：3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001 ；因此，3&amp;5的值得1。</p></div><h3 id="java-中的参数传递时传值呢-还是传引用" tabindex="-1"><a class="header-anchor" href="#java-中的参数传递时传值呢-还是传引用"><span>Java 中的参数传递时传值呢？还是传引用？</span></a></h3><ul><li>Java 的参数是以值传递的形式传入方法中，而不是引用传递。<br><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="noopener noreferrer">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></li></ul><h3 id="java-中的-math-round-1-5-等于多少" tabindex="-1"><a class="header-anchor" href="#java-中的-math-round-1-5-等于多少"><span>Java 中的 Math.round(-1.5) 等于多少？</span></a></h3><ul><li>Math.round(-1.5) 的返回值是 -1。四舍五入的原理是在参数上加 0.5 然后做向下取整。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//2</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//2</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//2</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//-1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//-1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//-1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.6</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//-2</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">round</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//-2</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="如何实现对象的克隆" tabindex="-1"><a class="header-anchor" href="#如何实现对象的克隆"><span>如何实现对象的克隆？</span></a></h3><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone()方法.</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆.</li></ul><h3 id="深克隆和浅克隆的区别" tabindex="-1"><a class="header-anchor" href="#深克隆和浅克隆的区别"><span>深克隆和浅克隆的区别？</span></a></h3><ul><li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li></ul><h3 id="什么是-java-的序列化-如何实现-java-的序列化" tabindex="-1"><a class="header-anchor" href="#什么是-java-的序列化-如何实现-java-的序列化"><span>什么是 Java 的序列化，如何实现 Java 的序列化？</span></a></h3><ul><li>序列化：把 Java 对象转换为字节序列的过程。</li><li>反序列化：把字节序列恢复为 Java 对象的过程。</li></ul><h3 id="什么情况下需要序列化" tabindex="-1"><a class="header-anchor" href="#什么情况下需要序列化"><span>什么情况下需要序列化？</span></a></h3><ul><li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li><li>在网络上传送对象的字节序列。</li></ul><h3 id="java-的泛型是如何工作的-什么是类型擦除" tabindex="-1"><a class="header-anchor" href="#java-的泛型是如何工作的-什么是类型擦除"><span>Java 的泛型是如何工作的 ? 什么是类型擦除 ?</span></a></h3><ul><li>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。</li><li>类型擦除:将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样</li></ul><h3 id="什么是泛型中的限定通配符和非限定通配符" tabindex="-1"><a class="header-anchor" href="#什么是泛型中的限定通配符和非限定通配符"><span>什么是泛型中的限定通配符和非限定通配符 ?</span></a></h3><ul><li>限定通配符 <ul><li><code>&lt;? extends T&gt;</code> 它通过确保类型必须是T及T的子类来设定类型的上界。</li><li><code>&lt;? super T&gt;</code> 它通过确保类型必须是T及T的父类设定类型的下界。</li></ul></li><li>非限定通配符 <ul><li>类型为 <code>&lt;T&gt;</code>,可以用任意类型来替代。</li></ul></li></ul><h3 id="list-和-arraylist-之间有什么区别" tabindex="-1"><a class="header-anchor" href="#list-和-arraylist-之间有什么区别"><span>List 和 ArrayList 之间有什么区别 ?</span></a></h3><ul><li>List 是一个接口，而 ListArray 是一个类。</li><li>ListArray 继承并实现了 List。</li></ul><h3 id="java-中的反射是什么意思-有哪些应用场景" tabindex="-1"><a class="header-anchor" href="#java-中的反射是什么意思-有哪些应用场景"><span>Java 中的反射是什么意思？有哪些应用场景？</span></a></h3><blockquote><p>Java 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。<br> 也就是说，反射本质上是一个“反着来”的过程。我们通过 new 创建一个类的实例时，<br> 实际上是由 Java 虚拟机根据这个类的 Class 对象在运行时构建出来的，<br> 而反射是通过一个类的 Class 对象来获取它的定义信息，从而我们可以访问到它的属性、方法，<br> 知道这个类的父类、实现了哪些接口等信息。</p></blockquote><h3 id="反射的优缺点" tabindex="-1"><a class="header-anchor" href="#反射的优缺点"><span>反射的优缺点？</span></a></h3><ul><li>优点 <ul><li>增加程序的灵活性，避免将程序写死到代码里。</li><li>代码简洁，提高代码的复用率，外部调用方便</li><li>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法</li></ul></li><li>缺点 <ul><li>性能问题</li><li>使用反射会模糊程序内部逻辑</li><li>安全限制</li><li>内部暴露</li></ul></li></ul><h3 id="java-中的动态代理是什么-有哪些应用" tabindex="-1"><a class="header-anchor" href="#java-中的动态代理是什么-有哪些应用"><span>Java 中的动态代理是什么？有哪些应用？</span></a></h3><ul><li>动态代理 <ul><li>动态代理是一种在运行时动态地创建代理对象，动态地处理代理方法调用的机制。</li><li>实际上它是一种代理机制。代理可以看做是对调用目标的一个封装，直接通过代理来实现对目标代码的调用。</li></ul></li><li>应用 <ul><li>Spring AOP 的动态代理实现</li><li>RPC 框架中的应用</li></ul></li></ul><h3 id="怎么实现动态代理" tabindex="-1"><a class="header-anchor" href="#怎么实现动态代理"><span>怎么实现动态代理？</span></a></h3><ul><li>JDK 动态代理 <ul><li>利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。</li></ul></li><li>CGlib 动态代理 <ul><li>利用 ASM（开源的 Java 字节码编辑库，操作字节码）开源包，将代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。</li></ul></li><li>区别 <ul><li>JDK 代理只能对实现接口的类生成代理；CGlib 是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理 final 修饰的类。</li></ul></li></ul><h3 id="static-关键字的作用" tabindex="-1"><a class="header-anchor" href="#static-关键字的作用"><span>static 关键字的作用？</span></a></h3><ul><li>声明 <ul><li>静态变量</li><li>静态方法</li><li>静态语句块</li><li>静态内部类</li><li>静态导包</li></ul></li></ul><h3 id="super-关键字的作用" tabindex="-1"><a class="header-anchor" href="#super-关键字的作用"><span>super 关键字的作用？</span></a></h3><ul><li>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><h3 id="字节和字符的区别" tabindex="-1"><a class="header-anchor" href="#字节和字符的区别"><span>字节和字符的区别？</span></a></h3><ul><li>字节(Byte)是计量单位，表示数据量多少，是计算机存储容量的计量单位。一个字节占8位。</li><li>字符(Character)计算机中使用的文字和符号，比如&#39;A&#39;、&#39;B&#39;、&#39;$&#39;、&#39;&amp;&#39;等。</li></ul><h3 id="string-为什么要设计为不可变类" tabindex="-1"><a class="header-anchor" href="#string-为什么要设计为不可变类"><span><a href="https://www.pdai.tech/md/java/basic/java-basic-lan-basic.html#string" target="_blank" rel="noopener noreferrer">String 为什么要设计为不可变类？</a></span></a></h3><ul><li>可以缓存 hash 值</li><li>String Pool 的需要</li><li>安全性</li><li>线程安全</li></ul><h3 id="string、stringbuilder、stringbuffer-的区别" tabindex="-1"><a class="header-anchor" href="#string、stringbuilder、stringbuffer-的区别"><span>String、StringBuilder、StringBuffer 的区别？</span></a></h3><ul><li>可变性 <ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul></li><li>线程安全 <ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul></li></ul><h3 id="string-字符串修改实现的原理" tabindex="-1"><a class="header-anchor" href="#string-字符串修改实现的原理"><span>String 字符串修改实现的原理？</span></a></h3><ul><li>String 对象值是不可变的，一切操作都不会改变 String 的值，而是通过构造新的字符串来实现字符串操作。</li></ul><h3 id="string-str-i-与-string-str-new-string-i-一样吗" tabindex="-1"><a class="header-anchor" href="#string-str-i-与-string-str-new-string-i-一样吗"><span>String str = &quot;i&quot; 与 String str = new String(&quot;i&quot;) 一样吗？</span></a></h3><ul><li>不一样 <ul><li>使用String str=&quot;i&quot;，java虚拟机会把它分配到常量池中。</li><li>String str=new String(“i”)创建了一个对象，会被分到堆内存中。</li></ul></li></ul><h3 id="string-类的常用方法都有那些" tabindex="-1"><a class="header-anchor" href="#string-类的常用方法都有那些"><span>String 类的常用方法都有那些？</span></a></h3><ul><li>length() 字符串的长度</li><li>charAt() 截取一个字符</li><li>getChars() 截取多个字符</li><li>getBytes()</li><li>toCharArray()</li><li>equals() 和 equalsIgnoreCase()</li><li>regionMatches() <ul><li>用于比较一个字符串中特定区域与另一特定区域，它有一个重载的形式允许在比较中忽略大小写。</li></ul></li><li>startsWith()和endsWith()</li><li>equals() 和==</li><li>compareTo() 和 compareToIgnoreCase()</li><li>indexOf() 和 lastIndexOf()</li><li>substring()</li><li>concat() 连接两个字符串</li><li>replace() 替换</li><li>trim() 去掉起始和结尾的空格</li><li>valueOf()</li><li>toLowerCase()</li><li>toUpperCase()</li></ul><h3 id="final-修饰-stringbuffer-后还可以-append-吗" tabindex="-1"><a class="header-anchor" href="#final-修饰-stringbuffer-后还可以-append-吗"><span>final 修饰 StringBuffer 后还可以 append 吗？</span></a></h3><ul><li>可以 <ul><li>final 修饰的是一个引用变量，那么这个引用始终只能指向这个对象，但是这个对象内部的属性是可以变化的。</li></ul></li></ul><h3 id="java-中的-io-流的分类-说出几个你熟悉的实现类" tabindex="-1"><a class="header-anchor" href="#java-中的-io-流的分类-说出几个你熟悉的实现类"><span>Java 中的 IO 流的分类？说出几个你熟悉的实现类？</span></a></h3><ul><li>字节流<br><img src="`+e+'" alt="java-io-byte"></li><li>字符流</li><li><img src="'+l+'" alt="java-io-character"></li></ul><h3 id="字节流和字符流有什么区别" tabindex="-1"><a class="header-anchor" href="#字节流和字符流有什么区别"><span>字节流和字符流有什么区别？</span></a></h3><ul><li>字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节。)</li><li>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li><li>简而言之，字节是个计算机看的，字符才是给人看的。</li></ul><h3 id="bio、nio、aio-有什么区别" tabindex="-1"><a class="header-anchor" href="#bio、nio、aio-有什么区别"><span>BIO、NIO、AIO 有什么区别？</span></a></h3><ul><li>BIO 就是传统的 <a href="http://java.io" target="_blank" rel="noopener noreferrer">java.io</a> 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，<br> 线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，<br> 同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），<br> 异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ul><h2 id="二、java异常-9-道" tabindex="-1"><a class="header-anchor" href="#二、java异常-9-道"><span>二、Java异常 9 道</span></a></h2><h3 id="finally-块中的代码什么时候被执行" tabindex="-1"><a class="header-anchor" href="#finally-块中的代码什么时候被执行"><span>finally 块中的代码什么时候被执行？</span></a></h3><ul><li>finally 不管有没有异常都要处理</li><li>当 try 和 catch 中有 return 时，finally 仍然会执行，finally 比 return 先执行</li><li>不管有木有异常抛出, finally 在 return 返回前执行</li><li>finally 是在 return 后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管 finally 中的代码怎么样，<br> 返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在 finally 执行前确定的</li></ul><h3 id="finally-是不是一定会被执行到" tabindex="-1"><a class="header-anchor" href="#finally-是不是一定会被执行到"><span>finally 是不是一定会被执行到？</span></a></h3><ul><li>finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值</li><li>finally 不执行的几种情况: 程序提前终止如调用了 System.exit, 病毒，断电</li></ul><h3 id="try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗" tabindex="-1"><a class="header-anchor" href="#try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗"><span>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</span></a></h3><ul><li>当 try 和 catch 中有 return 时，finally 仍然会执行，finally 比 return 先执行</li></ul><h3 id="try-catch-finally-中那个部分可以省略" tabindex="-1"><a class="header-anchor" href="#try-catch-finally-中那个部分可以省略"><span>try-catch-finally 中那个部分可以省略？</span></a></h3><ul><li>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</li></ul><h3 id="error-和-exception-的区别" tabindex="-1"><a class="header-anchor" href="#error-和-exception-的区别"><span>Error 和 Exception 的区别？</span></a></h3><ul><li><a href="https://www.pdai.tech/md/java/basic/java-basic-x-exception.html#error%E9%94%99%E8%AF%AF" target="_blank" rel="noopener noreferrer">Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</a></li><li><a href="https://www.pdai.tech/md/java/basic/java-basic-x-exception.html#exception%E5%BC%82%E5%B8%B8" target="_blank" rel="noopener noreferrer">程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</a></li></ul><h3 id="运行时异常与受检异常有何异同" tabindex="-1"><a class="header-anchor" href="#运行时异常与受检异常有何异同"><span>运行时异常与受检异常有何异同？</span></a></h3><ul><li>运行时异常 (runtime exceptions), 需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除... <ul><li>常见的runtime exception: NullPointerException ArithmeticException ClassCastException IllegalArgumentException IllegalStateException IndexOutOfBoundsException NoSuchElementException</li></ul></li><li>受检查的异常(checked exceptions),其必须被try...catch语句块所捕获, 或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查, Java虚拟机也要进行检查, 以确保这个规则得到遵守。 <ul><li>常见的checked exception: ClassNotFoundException IOException FileNotFoundException EOFException</li></ul></li></ul><h3 id="throw-和-throws-的区别" tabindex="-1"><a class="header-anchor" href="#throw-和-throws-的区别"><span>throw 和 throws 的区别？</span></a></h3><ul><li>异常的申明 (throws) <ul><li>在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。</li></ul></li><li>异常的抛出 (throw) <ul><li>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。</li></ul></li></ul><h3 id="常见的异常类有哪些" tabindex="-1"><a class="header-anchor" href="#常见的异常类有哪些"><span>常见的异常类有哪些？</span></a></h3><ul><li>常见的runtime exception: NullPointerException ArithmeticException ClassCastException IllegalArgumentException IllegalStateException IndexOutOfBoundsException NoSuchElementException</li></ul><h3 id="主线程可以捕获到子线程的异常吗" tabindex="-1"><a class="header-anchor" href="#主线程可以捕获到子线程的异常吗"><span>主线程可以捕获到子线程的异常吗？</span></a></h3><ul><li>线程的问题应该线程自己本身来解决，而不要委托到外部。 <ul><li>特殊处理 <ul><li>子线程中 try... catch...</li><li>为线程设置 “未捕获异常处理器” UncaughtExceptionHandler</li><li>通过 Future 的 get 方法捕获异常（推荐</li></ul></li></ul></li></ul><h2 id="三、java集合-24-道" tabindex="-1"><a class="header-anchor" href="#三、java集合-24-道"><span>三、Java集合 24 道</span></a></h2><h3 id="java-中常用的容器有哪些" tabindex="-1"><a class="header-anchor" href="#java-中常用的容器有哪些"><span>Java 中常用的容器有哪些？</span></a></h3><ul><li>ArrayList、LinkedList、Vector、HashSet、LinkedHashSet、TreeSet、LinkedHashMap、TreeMap、ConcurrentHashMap、Hashtable等等。<br><img src="'+r+'" alt="Java集合容器"></li></ul><h3 id="arraylist-和-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#arraylist-和-linkedlist-的区别"><span>ArrayList 和 LinkedList 的区别？</span></a></h3><ul><li>ArrayList <ul><li>基于动态数组实现，支持随机访问。</li></ul></li><li>LinkedList <ul><li>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul></li></ul><h3 id="arraylist-实现-randomaccess-接口有何作用-为何-linkedlist-却没实现这个接口" tabindex="-1"><a class="header-anchor" href="#arraylist-实现-randomaccess-接口有何作用-为何-linkedlist-却没实现这个接口"><span>ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？</span></a></h3><ul><li>RandomAccess 是一个标记接口，内部是空的，标记“实现了这个接口的类支持快速（通常是固定时间）随机访问”。</li><li>LinkedList 没有实现 RandomAccess 接口，这是因为 LinkedList 存储数据的内存地址是不连续的，所以不支持随机访问。</li></ul><h3 id="arraylist-的扩容机制" tabindex="-1"><a class="header-anchor" href="#arraylist-的扩容机制"><span>ArrayList 的扩容机制？</span></a></h3><ul><li>ArrayList 是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。<br> 所以在插入时候，会先检查是否需要扩容，如果当前容量 +1 超过数组长度，就会进行扩容。</li><li>ArrayList 的扩容是创建一个 1.5 倍的新数组，然后把原数组的值拷贝过去。</li><li></li></ul><h3 id="array-和-arraylist-有何区别-什么时候更适合用-array" tabindex="-1"><a class="header-anchor" href="#array-和-arraylist-有何区别-什么时候更适合用-array"><span>Array 和 ArrayList 有何区别？什么时候更适合用 Array？</span></a></h3><ul><li>Array：它是数组，申明数组的时候就要初始化并确定长度，长度不可变，而且它只能存储同一类型的数据，比如申明为 String 类型的数组，那么它只能存储 String 类型数据。</li><li>ArrayList：它是一个集合，需要先申明，然后再添加数据，长度是根据内容的多少而改变的，ArrayList 可以存放不同类型的数据，在存储基本类型数据的时候要使用基本数据类型的包装类。</li><li>当能确定长度并且数据类型一致的时候就可以用数组，其他时候使用ArrayList。</li></ul><h3 id="hashmap-的实现原理-底层数据结构-jdk1-7-和-jdk1-8" tabindex="-1"><a class="header-anchor" href="#hashmap-的实现原理-底层数据结构-jdk1-7-和-jdk1-8"><span>HashMap 的实现原理/底层数据结构？JDK1.7 和 JDK1.8</span></a></h3><ul><li>JDK 7 中，HashMap 由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li>在 JDK 8 中，HashMap 由“数组+链表+红黑树”组成。链表过长，会严重影响 HashMap 的性能，而红黑树搜索的时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK 8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换。</li></ul><h3 id="hashmap-的-put-方法的执行过程" tabindex="-1"><a class="header-anchor" href="#hashmap-的-put-方法的执行过程"><span><a href="https://tobebetterjavaer.com/collection/hashmap-interview.html#_10%E3%80%81hashmap-%E7%9A%84put%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener noreferrer">HashMap 的 put 方法的执行过程？</a></span></a></h3><ul><li>Java 1.7<br><img src="'+t+'" alt="HashMap 的 put 流程"></li><li>Java 1.8<br><img src="'+p+'" alt="HashMap 的 put 流程"></li></ul><h3 id="hashmap-的-get-方法的执行过程" tabindex="-1"><a class="header-anchor" href="#hashmap-的-get-方法的执行过程"><span>HashMap 的 get 方法的执行过程？</span></a></h3><ul><li>Java 1.7<br><img src="'+d+'" alt="HashMap 的 get 流程"></li><li>Java 1.8<br><img src="'+c+`" alt="HashMap 的 get 流程"></li></ul><h3 id="hashmap-的-resize-方法的执行过程" tabindex="-1"><a class="header-anchor" href="#hashmap-的-resize-方法的执行过程"><span>HashMap 的 resize 方法的执行过程？</span></a></h3><ul><li>初始化数组 table，并设置阈值。</li><li>数组容量翻倍，将元素迁移到新数组。</li></ul><h3 id="hashmap-的-size-为什么必须是-2-的整数次方" tabindex="-1"><a class="header-anchor" href="#hashmap-的-size-为什么必须是-2-的整数次方"><span><a href="https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg" target="_blank" rel="noopener noreferrer">HashMap 的 size 为什么必须是 2 的整数次方？</a></span></a></h3><h3 id="hashmap-多线程死循环问题" tabindex="-1"><a class="header-anchor" href="#hashmap-多线程死循环问题"><span>HashMap 多线程死循环问题？</span></a></h3><ul><li>多线程下扩容死循环。JDK1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li></ul><h3 id="hashmap-的-get-方法能否判断某个元素是否在-map-中" tabindex="-1"><a class="header-anchor" href="#hashmap-的-get-方法能否判断某个元素是否在-map-中"><span>HashMap 的 get 方法能否判断某个元素是否在 map 中？</span></a></h3><ul><li>HashMap 的 get 函数的返回值不能判断一个 key 是否包含在 map 中，因为 get 返回 null 有可能是不包含该 key，也有可能该 key 对应的 value 为 null。因为 HashMap 中允许 key 为 null，也允许 value 为 null。</li></ul><h3 id="hashmap-与-hashtable-的区别是什么" tabindex="-1"><a class="header-anchor" href="#hashmap-与-hashtable-的区别是什么"><span>HashMap 与 HashTable 的区别是什么？</span></a></h3><ul><li>HashMap 是 Hashtable 的轻量级实现，HashMap 允许 key 和 value 为 null，但最多允许一条记录的 key 为 null.而 HashTable 不允许。</li><li>HashTable 中的方法是线程安全的，而 HashMap 不是。在多线程访问 HashMap 需要提供额外的同步机制。</li><li>Hashtable 使用 Enumeration 进行遍历，HashMap 使用 Iterator 进行遍历</li></ul><h3 id="hashmap-与-concurrenthashmap-的区别是什么" tabindex="-1"><a class="header-anchor" href="#hashmap-与-concurrenthashmap-的区别是什么"><span>HashMap 与 ConcurrentHashMap 的区别是什么?</span></a></h3><ul><li>HashMap <ul><li>HashMap 是线程不安全的，当出现多线程操作时，会出现安全隐患；而 ConcurrentHashMap 是线程安全的。</li><li>HashMap 不支持并发操作，没有同步方法，ConcurrentHashMap 支持并发操作，通过继承 ReentrantLock（JDK1.7 重入锁）/CAS 和 synchronized(JDK1.8 内置锁) 来进行加锁（分段锁），每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</li></ul></li><li>ConcurrentHashMap <ul><li>ConcurrentHashMap 采用锁分段技术，将整个 Hash 桶进行了分段 segment，也就是将这个大的数组分成了几个小的片段 segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁。</li><li>ConcurrentHashMap 让锁的粒度更精细一些，并发性能更好。</li></ul></li></ul><h3 id="hashtable-和-concurrenthashmap-的区别" tabindex="-1"><a class="header-anchor" href="#hashtable-和-concurrenthashmap-的区别"><span>HashTable 和 ConcurrentHashMap 的区别？</span></a></h3><h3 id="concurrenthashmap-的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-的实现原理是什么"><span>ConcurrentHashMap 的实现原理是什么？</span></a></h3><ul><li>JDK7采用锁分段技术。</li><li>JDK8的改进 <ul><li>取消分段锁机制，采用CAS算法进行值的设置，如果CAS失败再使用 synchronized 加锁添加元素</li><li>引入红黑树结构，当某个槽内的元素个数超过8且 Node数组 容量大于 64 时，链表转为红黑树。</li><li>使用了更加优化的方式统计集合内的元素数量。</li></ul></li></ul><h3 id="hashset-的实现原理" tabindex="-1"><a class="header-anchor" href="#hashset-的实现原理"><span>HashSet 的实现原理？</span></a></h3><ul><li>HashSet 是基于 HashMap 实现的，底层采用 HashMap 来保存元素</li></ul><h3 id="hashset-怎么保证元素不重复的" tabindex="-1"><a class="header-anchor" href="#hashset-怎么保证元素不重复的"><span>HashSet 怎么保证元素不重复的？</span></a></h3><ul><li>元素的哈希值是通过元素的 hashcode 方法 来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</li></ul><h3 id="linkedhashmap-的实现原理" tabindex="-1"><a class="header-anchor" href="#linkedhashmap-的实现原理"><span>LinkedHashMap 的实现原理?</span></a></h3><ul><li>LinkedHashMap维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。</li></ul><h3 id="iterator-怎么使用-有什么特点" tabindex="-1"><a class="header-anchor" href="#iterator-怎么使用-有什么特点"><span>Iterator 怎么使用？有什么特点？</span></a></h3><ul><li>使用方法 iterator() 要求容器返回一个 Iterator。第一次调用 Iterator 的 next() 方法时，它返回序列的第一个元素。注意：iterator() 方法是 java.lang.Iterable 接口,被 Collection 继承。</li><li>使用 next() 获得序列中的下一个元素。</li><li>使用 hasNext() 检查序列中是否还有元素。</li><li>使用 remove() 将迭代器新返回的元素删除。</li><li>迭代器模式 (iterator pattern): 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示。</li></ul><h3 id="iterator-和-listiterator-有什么区别" tabindex="-1"><a class="header-anchor" href="#iterator-和-listiterator-有什么区别"><span>Iterator 和 ListIterator 有什么区别？</span></a></h3><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator即可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素、替换元素、获取前一个和后一个元素的索引等。</li></ul><h3 id="iterator-和-enumeration-接口的区别" tabindex="-1"><a class="header-anchor" href="#iterator-和-enumeration-接口的区别"><span>Iterator 和 Enumeration 接口的区别？</span></a></h3><ul><li>Iterator 除了能读取集合的数据之外，也能数据进行删除操作；而 Enumeration 只能读取集合的数据，而不能对数据进行修改。</li><li>Iterator 支持 fail-fast 机制，而 Enumeration 不支持 fail-fast 机制。Enumeration 是 JDK 1.0 添加的接口。<br> 使用到它的函数包括 Vector、Hashtable 等类，这些类都是 JDK1.0 中加入的。Iterator 是 JDK1.2 添加的接口，<br> Iterator 是基于 Enumeration 实现的，同时 Iterator 支持 fail-fast 机制，所以 Iterator 遍历集合时会比 Enumeration 遍历集合慢一些。</li></ul><h3 id="fail-fast-与-fail-safe-有什么区别" tabindex="-1"><a class="header-anchor" href="#fail-fast-与-fail-safe-有什么区别"><span>fail-fast 与 fail-safe 有什么区别？</span></a></h3><ul><li>fail-fast 直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出 ConcurrentModificationException 异常从而导致遍历失败。常见的使用 fail-fast 方式的容器有 HashMap 和 ArrayList 等。</li><li>fail-safe 这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用 fail-safe 方式遍历的容器有 ConcurrentHashMap 和 CopyOnWriteArrayList。</li></ul><h3 id="collection-和-collections-有什么区别" tabindex="-1"><a class="header-anchor" href="#collection-和-collections-有什么区别"><span>Collection 和 Collections 有什么区别？</span></a></h3><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法：Collections.sort(list);提供的反转方法：Collections.reverse(list)。</li></ul><h2 id="四、java并发-42-道" tabindex="-1"><a class="header-anchor" href="#四、java并发-42-道"><span>四、Java并发 42 道</span></a></h2><h3 id="并行和并发有什么区别" tabindex="-1"><a class="header-anchor" href="#并行和并发有什么区别"><span>并行和并发有什么区别？</span></a></h3><ul><li>并发是指一个处理器同时处理多个任务。</li><li>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</li></ul><h3 id="线程和进程的区别" tabindex="-1"><a class="header-anchor" href="#线程和进程的区别"><span>线程和进程的区别？</span></a></h3><ul><li>进程是资源分配的最小单位</li><li>线程是CPU调度的最小单位</li><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li></ul><h3 id="守护线程是什么" tabindex="-1"><a class="header-anchor" href="#守护线程是什么"><span>守护线程是什么？</span></a></h3><ul><li>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</li></ul><h3 id="创建线程的几种方式" tabindex="-1"><a class="header-anchor" href="#创建线程的几种方式"><span>创建线程的几种方式？</span></a></h3><ul><li>继承Thread类，重写run()方法</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Demo</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //重写父类Thread的run()</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Demo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> d1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Demo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> d2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        d1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        d2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>实现Runnable接口，重写run()</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Demo2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Runnable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //重写Runnable接口的run()</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Demo2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Demo2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>实现 Callable 接口</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Demo</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Callable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Exception</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;正在执行新建线程任务&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;结果&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> InterruptedException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ExecutionException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Demo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> d</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        FutureTask</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">task</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FutureTask</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;(d);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(task);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        //获取任务执行后返回的结果</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> result</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> task</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用线程池创建</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Executor</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> threadPool</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Executors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newFixedThreadPool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ;i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ; i++) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            threadPool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">execute</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Runnable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    //todo</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            });</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="runnable-和-callable-有什么区别" tabindex="-1"><a class="header-anchor" href="#runnable-和-callable-有什么区别"><span>Runnable 和 Callable 有什么区别？</span></a></h3><ul><li>与 Runnable 相比，Callable 可以有返回值</li></ul><h3 id="线程状态及转换" tabindex="-1"><a class="header-anchor" href="#线程状态及转换"><span>线程状态及转换？</span></a></h3><ul><li><a href="https://tobebetterjavaer.com/thread/thread-state-and-method.html#new" target="_blank" rel="noopener noreferrer">Java 线程的6种状态及切换(透彻讲解)</a></li></ul><h3 id="sleep-和-wait-的区别" tabindex="-1"><a class="header-anchor" href="#sleep-和-wait-的区别"><span><a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html#threadsleep%E5%92%8Cobjectwait%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">sleep() 和 wait() 的区别？</a></span></a></h3><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h3 id="线程的-run-和-start-有什么区别" tabindex="-1"><a class="header-anchor" href="#线程的-run-和-start-有什么区别"><span>线程的 run() 和 start() 有什么区别？</span></a></h3><ul><li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li></ul><h3 id="在-java-程序中怎么保证多线程的运行安全" tabindex="-1"><a class="header-anchor" href="#在-java-程序中怎么保证多线程的运行安全"><span><a href="https://www.pdai.tech/md/java/thread/java-thread-x-theorty.html#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">在 Java 程序中怎么保证多线程的运行安全？</a></span></a></h3><h3 id="java-线程同步的几种方法" tabindex="-1"><a class="header-anchor" href="#java-线程同步的几种方法"><span>Java 线程同步的几种方法？</span></a></h3><ul><li>互斥同步</li><li>非阻塞同步</li></ul><h3 id="thread-interrupt-方法的工作原理是什么" tabindex="-1"><a class="header-anchor" href="#thread-interrupt-方法的工作原理是什么"><span>Thread.interrupt() 方法的工作原理是什么？</span></a></h3><ul><li>设置线程的中断状态为 true（默认是 flase）。</li></ul><h3 id="谈谈对-threadlocal-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对-threadlocal-的理解"><span>谈谈对 ThreadLocal 的理解？</span></a></h3><ul><li>从ThreadLocal 这个类名可以顾名思义的进行理解，表示线程的“本地变量”，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的这样就可以避免共享资源的竞争。</li></ul><h3 id="在哪些场景下会使用到-threadlocal" tabindex="-1"><a class="header-anchor" href="#在哪些场景下会使用到-threadlocal"><span>在哪些场景下会使用到 ThreadLocal？</span></a></h3><ul><li>threadLocal 只适用于共享对象会造成线程安全的业务场景。</li></ul><h3 id="说一说自己对于-synchronized-关键字的了解" tabindex="-1"><a class="header-anchor" href="#说一说自己对于-synchronized-关键字的了解"><span>说一说自己对于 synchronized 关键字的了解？</span></a></h3><h3 id="如何在项目中使用-synchronized-的" tabindex="-1"><a class="header-anchor" href="#如何在项目中使用-synchronized-的"><span>如何在项目中使用 synchronized 的？</span></a></h3><h3 id="说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" tabindex="-1"><a class="header-anchor" href="#说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗"><span>说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</span></a></h3><h3 id="谈谈-synchronized-和-reentrantlock-的区别" tabindex="-1"><a class="header-anchor" href="#谈谈-synchronized-和-reentrantlock-的区别"><span>谈谈 synchronized 和 ReenTrantLock 的区别？</span></a></h3><h3 id="synchronized-和-volatile-的区别是什么" tabindex="-1"><a class="header-anchor" href="#synchronized-和-volatile-的区别是什么"><span>synchronized 和 volatile 的区别是什么？</span></a></h3><h3 id="谈一下你对-volatile-关键字的理解" tabindex="-1"><a class="header-anchor" href="#谈一下你对-volatile-关键字的理解"><span>谈一下你对 volatile 关键字的理解？</span></a></h3><h3 id="说下对-reentrantreadwritelock-的理解" tabindex="-1"><a class="header-anchor" href="#说下对-reentrantreadwritelock-的理解"><span>说下对 ReentrantReadWriteLock 的理解？</span></a></h3><h3 id="说下对悲观锁和乐观锁的理解" tabindex="-1"><a class="header-anchor" href="#说下对悲观锁和乐观锁的理解"><span>说下对悲观锁和乐观锁的理解？</span></a></h3><h3 id="乐观锁常见的两种实现方式是什么" tabindex="-1"><a class="header-anchor" href="#乐观锁常见的两种实现方式是什么"><span>乐观锁常见的两种实现方式是什么？</span></a></h3><h3 id="乐观锁的缺点有哪些" tabindex="-1"><a class="header-anchor" href="#乐观锁的缺点有哪些"><span>乐观锁的缺点有哪些？</span></a></h3><h3 id="cas-和-synchronized-的使用场景" tabindex="-1"><a class="header-anchor" href="#cas-和-synchronized-的使用场景"><span>CAS 和 synchronized 的使用场景？</span></a></h3><h3 id="简单说下对-java-中的原子类的理解" tabindex="-1"><a class="header-anchor" href="#简单说下对-java-中的原子类的理解"><span>简单说下对 Java 中的原子类的理解？</span></a></h3><h3 id="atomic-的原理是什么" tabindex="-1"><a class="header-anchor" href="#atomic-的原理是什么"><span>atomic 的原理是什么？</span></a></h3><h3 id="说下对同步器-aqs-的理解" tabindex="-1"><a class="header-anchor" href="#说下对同步器-aqs-的理解"><span>说下对同步器 AQS 的理解？</span></a></h3><h3 id="aqs-的原理是什么" tabindex="-1"><a class="header-anchor" href="#aqs-的原理是什么"><span>AQS 的原理是什么？</span></a></h3><h3 id="aqs-对资源的共享模式有哪些" tabindex="-1"><a class="header-anchor" href="#aqs-对资源的共享模式有哪些"><span>AQS 对资源的共享模式有哪些？</span></a></h3><h3 id="aqs-底层使用了模板方法模式-你能说出几个需要重写的方法吗" tabindex="-1"><a class="header-anchor" href="#aqs-底层使用了模板方法模式-你能说出几个需要重写的方法吗"><span>AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗？</span></a></h3><h3 id="说下对信号量-semaphore-的理解" tabindex="-1"><a class="header-anchor" href="#说下对信号量-semaphore-的理解"><span>说下对信号量 Semaphore 的理解？</span></a></h3><h3 id="countdownlatch-和-cyclicbarrier-有什么区别" tabindex="-1"><a class="header-anchor" href="#countdownlatch-和-cyclicbarrier-有什么区别"><span>CountDownLatch 和 CyclicBarrier 有什么区别？</span></a></h3><h3 id="说下对线程池的理解-为什么要使用线程池" tabindex="-1"><a class="header-anchor" href="#说下对线程池的理解-为什么要使用线程池"><span>说下对线程池的理解？为什么要使用线程池？</span></a></h3><h3 id="创建线程池的参数有哪些" tabindex="-1"><a class="header-anchor" href="#创建线程池的参数有哪些"><span>创建线程池的参数有哪些？</span></a></h3><h3 id="如何创建线程池" tabindex="-1"><a class="header-anchor" href="#如何创建线程池"><span>如何创建线程池？</span></a></h3><h3 id="线程池中的的线程数一般怎么设置-需要考虑哪些问题" tabindex="-1"><a class="header-anchor" href="#线程池中的的线程数一般怎么设置-需要考虑哪些问题"><span>线程池中的的线程数一般怎么设置？需要考虑哪些问题？</span></a></h3><h3 id="执行-execute-方法和-submit-方法的区别是什么呢" tabindex="-1"><a class="header-anchor" href="#执行-execute-方法和-submit-方法的区别是什么呢"><span>执行 execute() 方法和 submit() 方法的区别是什么呢？</span></a></h3><h3 id="说下对-fork和join-并行计算框架的理解" tabindex="-1"><a class="header-anchor" href="#说下对-fork和join-并行计算框架的理解"><span>说下对 Fork和Join 并行计算框架的理解？</span></a></h3><h3 id="jdk-中提供了哪些并发容器" tabindex="-1"><a class="header-anchor" href="#jdk-中提供了哪些并发容器"><span>JDK 中提供了哪些并发容器？</span></a></h3><h3 id="谈谈对-copyonwritearraylist-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对-copyonwritearraylist-的理解"><span>谈谈对 CopyOnWriteArrayList 的理解？</span></a></h3><h3 id="谈谈对-blockingqueue-的理解-分别有哪些实现类" tabindex="-1"><a class="header-anchor" href="#谈谈对-blockingqueue-的理解-分别有哪些实现类"><span>谈谈对 BlockingQueue 的理解？分别有哪些实现类？</span></a></h3><h3 id="谈谈对-concurrentskiplistmap-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对-concurrentskiplistmap-的理解"><span>谈谈对 ConcurrentSkipListMap 的理解？</span></a></h3><h2 id="五、java-jvm-42-道" tabindex="-1"><a class="header-anchor" href="#五、java-jvm-42-道"><span>五、Java JVM 42 道</span></a></h2><h3 id="说一下-jvm-的主要组成部分-及其作用" tabindex="-1"><a class="header-anchor" href="#说一下-jvm-的主要组成部分-及其作用"><span>说一下 Jvm 的主要组成部分？及其作用？</span></a></h3><h3 id="谈谈对运行时数据区的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对运行时数据区的理解"><span>谈谈对运行时数据区的理解？</span></a></h3><h3 id="堆和栈的区别是什么" tabindex="-1"><a class="header-anchor" href="#堆和栈的区别是什么"><span>堆和栈的区别是什么？</span></a></h3><h3 id="堆中存什么-栈中存什么" tabindex="-1"><a class="header-anchor" href="#堆中存什么-栈中存什么"><span>堆中存什么？栈中存什么？</span></a></h3><h3 id="为什么要把堆和栈区分出来呢-栈中不是也可以存储数据吗" tabindex="-1"><a class="header-anchor" href="#为什么要把堆和栈区分出来呢-栈中不是也可以存储数据吗"><span>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</span></a></h3><h3 id="java-中的参数传递时传值呢-还是传引用-1" tabindex="-1"><a class="header-anchor" href="#java-中的参数传递时传值呢-还是传引用-1"><span>Java 中的参数传递时传值呢？还是传引用？</span></a></h3><h3 id="java-对象的大小是怎么计算的" tabindex="-1"><a class="header-anchor" href="#java-对象的大小是怎么计算的"><span>Java 对象的大小是怎么计算的？</span></a></h3><h3 id="对象的访问定位的两种方式" tabindex="-1"><a class="header-anchor" href="#对象的访问定位的两种方式"><span>对象的访问定位的两种方式？</span></a></h3><h3 id="判断垃圾可以回收的方法有哪些" tabindex="-1"><a class="header-anchor" href="#判断垃圾可以回收的方法有哪些"><span>判断垃圾可以回收的方法有哪些？</span></a></h3><h3 id="垃圾回收是从哪里开始的呢" tabindex="-1"><a class="header-anchor" href="#垃圾回收是从哪里开始的呢"><span>垃圾回收是从哪里开始的呢？</span></a></h3><h3 id="被标记为垃圾的对象一定会被回收吗" tabindex="-1"><a class="header-anchor" href="#被标记为垃圾的对象一定会被回收吗"><span>被标记为垃圾的对象一定会被回收吗？</span></a></h3><h3 id="谈谈对-java-中引用的了解" tabindex="-1"><a class="header-anchor" href="#谈谈对-java-中引用的了解"><span>谈谈对 Java 中引用的了解？</span></a></h3><h3 id="谈谈对内存泄漏的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对内存泄漏的理解"><span>谈谈对内存泄漏的理解？</span></a></h3><h3 id="内存泄露的根本原因是什么" tabindex="-1"><a class="header-anchor" href="#内存泄露的根本原因是什么"><span>内存泄露的根本原因是什么？</span></a></h3><h3 id="举几个可能发生内存泄漏的情况" tabindex="-1"><a class="header-anchor" href="#举几个可能发生内存泄漏的情况"><span>举几个可能发生内存泄漏的情况？</span></a></h3><h3 id="尽量避免内存泄漏的方法" tabindex="-1"><a class="header-anchor" href="#尽量避免内存泄漏的方法"><span>尽量避免内存泄漏的方法？</span></a></h3><h3 id="常用的垃圾收集算法有哪些" tabindex="-1"><a class="header-anchor" href="#常用的垃圾收集算法有哪些"><span>常用的垃圾收集算法有哪些？</span></a></h3><h3 id="为什么要采用分代收集算法" tabindex="-1"><a class="header-anchor" href="#为什么要采用分代收集算法"><span>为什么要采用分代收集算法？</span></a></h3><h3 id="分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法"><span>分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法？</span></a></h3><h3 id="什么是浮动垃圾" tabindex="-1"><a class="header-anchor" href="#什么是浮动垃圾"><span>什么是浮动垃圾？</span></a></h3><h3 id="什么是内存碎片-如何解决" tabindex="-1"><a class="header-anchor" href="#什么是内存碎片-如何解决"><span>什么是内存碎片？如何解决？</span></a></h3><h3 id="常用的垃圾收集器有哪些" tabindex="-1"><a class="header-anchor" href="#常用的垃圾收集器有哪些"><span>常用的垃圾收集器有哪些？</span></a></h3><h3 id="谈谈你对-cms-垃圾收集器的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-cms-垃圾收集器的理解"><span>谈谈你对 CMS 垃圾收集器的理解？</span></a></h3><h3 id="谈谈你对-g1-收集器的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-g1-收集器的理解"><span>谈谈你对 G1 收集器的理解？</span></a></h3><h3 id="说下你对垃圾回收策略的理解-垃圾回收时机" tabindex="-1"><a class="header-anchor" href="#说下你对垃圾回收策略的理解-垃圾回收时机"><span>说下你对垃圾回收策略的理解/垃圾回收时机？</span></a></h3><h3 id="谈谈你对内存分配的理解-大对象怎么分配-空间分配担保" tabindex="-1"><a class="header-anchor" href="#谈谈你对内存分配的理解-大对象怎么分配-空间分配担保"><span>谈谈你对内存分配的理解？大对象怎么分配？空间分配担保？</span></a></h3><h3 id="说下你用过的-jvm-监控工具" tabindex="-1"><a class="header-anchor" href="#说下你用过的-jvm-监控工具"><span>说下你用过的 JVM 监控工具？</span></a></h3><h3 id="如何利用监控工具调优" tabindex="-1"><a class="header-anchor" href="#如何利用监控工具调优"><span>如何利用监控工具调优？</span></a></h3><h3 id="jvm-的一些参数" tabindex="-1"><a class="header-anchor" href="#jvm-的一些参数"><span>JVM 的一些参数？</span></a></h3><h3 id="谈谈你对类文件结构的理解-有哪些部分组成" tabindex="-1"><a class="header-anchor" href="#谈谈你对类文件结构的理解-有哪些部分组成"><span>谈谈你对类文件结构的理解？有哪些部分组成？</span></a></h3><h3 id="谈谈你对类加载机制的了解" tabindex="-1"><a class="header-anchor" href="#谈谈你对类加载机制的了解"><span>谈谈你对类加载机制的了解？</span></a></h3><h3 id="类加载各阶段的作用分别是什么" tabindex="-1"><a class="header-anchor" href="#类加载各阶段的作用分别是什么"><span>类加载各阶段的作用分别是什么？</span></a></h3><h3 id="有哪些类加载器-分别有什么作用" tabindex="-1"><a class="header-anchor" href="#有哪些类加载器-分别有什么作用"><span>有哪些类加载器？分别有什么作用？</span></a></h3><h3 id="类与类加载器的关系" tabindex="-1"><a class="header-anchor" href="#类与类加载器的关系"><span>类与类加载器的关系?</span></a></h3><h3 id="谈谈你对双亲委派模型的理解-工作过程-为什么要使用" tabindex="-1"><a class="header-anchor" href="#谈谈你对双亲委派模型的理解-工作过程-为什么要使用"><span>谈谈你对双亲委派模型的理解？工作过程？为什么要使用</span></a></h3><h3 id="怎么实现一个自定义的类加载器-需要注意什么" tabindex="-1"><a class="header-anchor" href="#怎么实现一个自定义的类加载器-需要注意什么"><span>怎么实现一个自定义的类加载器？需要注意什么？</span></a></h3><h3 id="怎么打破双亲委派模型" tabindex="-1"><a class="header-anchor" href="#怎么打破双亲委派模型"><span>怎么打破双亲委派模型？</span></a></h3><h3 id="有哪些实际场景是需要打破双亲委派模型的" tabindex="-1"><a class="header-anchor" href="#有哪些实际场景是需要打破双亲委派模型的"><span>有哪些实际场景是需要打破双亲委派模型的？</span></a></h3><h3 id="谈谈你对编译期优化和运行期优化的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对编译期优化和运行期优化的理解"><span>谈谈你对编译期优化和运行期优化的理解？</span></a></h3><h3 id="为何-hotspot-虚拟机要使用解释器与编译器并存的架构" tabindex="-1"><a class="header-anchor" href="#为何-hotspot-虚拟机要使用解释器与编译器并存的架构"><span>为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？</span></a></h3><h3 id="说下你对-java-内存模型的理解" tabindex="-1"><a class="header-anchor" href="#说下你对-java-内存模型的理解"><span>说下你对 Java 内存模型的理解？</span></a></h3><h3 id="内存间的交互操作有哪些-需要满足什么规则" tabindex="-1"><a class="header-anchor" href="#内存间的交互操作有哪些-需要满足什么规则"><span>内存间的交互操作有哪些？需要满足什么规则？</span></a></h3><h2 id="六、ssm框架-37-道" tabindex="-1"><a class="header-anchor" href="#六、ssm框架-37-道"><span>六、SSM框架 37 道</span></a></h2><h3 id="使用-spring-框架的好处是什么" tabindex="-1"><a class="header-anchor" href="#使用-spring-框架的好处是什么"><span>使用 Spring 框架的好处是什么？</span></a></h3><h3 id="解释下什么是-aop" tabindex="-1"><a class="header-anchor" href="#解释下什么是-aop"><span>解释下什么是 AOP？</span></a></h3><h3 id="aop-的代理有哪几种方式" tabindex="-1"><a class="header-anchor" href="#aop-的代理有哪几种方式"><span>AOP 的代理有哪几种方式？</span></a></h3><h3 id="怎么实现-jdk-动态代理" tabindex="-1"><a class="header-anchor" href="#怎么实现-jdk-动态代理"><span>怎么实现 JDK 动态代理？</span></a></h3><h3 id="aop-的基本概念-切面、连接点、切入点等" tabindex="-1"><a class="header-anchor" href="#aop-的基本概念-切面、连接点、切入点等"><span>AOP 的基本概念：切面、连接点、切入点等？</span></a></h3><h3 id="通知类型-advice-型-advice-有哪些" tabindex="-1"><a class="header-anchor" href="#通知类型-advice-型-advice-有哪些"><span>通知类型（Advice）型（Advice）有哪些？</span></a></h3><h3 id="谈谈你对-ioc-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-ioc-的理解"><span>谈谈你对 IOC 的理解？</span></a></h3><h3 id="bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#bean-的生命周期"><span>Bean 的生命周期？</span></a></h3><h3 id="bean-的作用域" tabindex="-1"><a class="header-anchor" href="#bean-的作用域"><span>Bean 的作用域?</span></a></h3><h3 id="spring-中的单例-bean-的线程安全问题了解吗" tabindex="-1"><a class="header-anchor" href="#spring-中的单例-bean-的线程安全问题了解吗"><span>Spring 中的单例 Bean 的线程安全问题了解吗？</span></a></h3><h3 id="谈谈你对-spring-中的事物的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-spring-中的事物的理解"><span>谈谈你对 Spring 中的事物的理解？</span></a></h3><h3 id="spring-中的事务隔离级别" tabindex="-1"><a class="header-anchor" href="#spring-中的事务隔离级别"><span>Spring 中的事务隔离级别？</span></a></h3><h3 id="spring-中的事物传播行为" tabindex="-1"><a class="header-anchor" href="#spring-中的事物传播行为"><span>Spring 中的事物传播行为？</span></a></h3><h3 id="spring-常用的注入方式有哪些" tabindex="-1"><a class="header-anchor" href="#spring-常用的注入方式有哪些"><span>Spring 常用的注入方式有哪些？</span></a></h3><h3 id="spring-框架中用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#spring-框架中用到了哪些设计模式"><span>Spring 框架中用到了哪些设计模式？</span></a></h3><h3 id="applicationcontext-通常的实现有哪些" tabindex="-1"><a class="header-anchor" href="#applicationcontext-通常的实现有哪些"><span>ApplicationContext 通常的实现有哪些?</span></a></h3><h3 id="谈谈你对-mvc-模式的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-mvc-模式的理解"><span>谈谈你对 MVC 模式的理解？</span></a></h3><h3 id="springmvc-的工作原理-执行流程" tabindex="-1"><a class="header-anchor" href="#springmvc-的工作原理-执行流程"><span>SpringMVC 的工作原理/执行流程？</span></a></h3><h3 id="springmvc-的核心组件有哪些" tabindex="-1"><a class="header-anchor" href="#springmvc-的核心组件有哪些"><span>SpringMVC 的核心组件有哪些？</span></a></h3><h3 id="springmvc-常用的注解有哪些" tabindex="-1"><a class="header-anchor" href="#springmvc-常用的注解有哪些"><span>SpringMVC 常用的注解有哪些？</span></a></h3><h3 id="requestmapping-的作用是什么" tabindex="-1"><a class="header-anchor" href="#requestmapping-的作用是什么"><span>@RequestMapping 的作用是什么？</span></a></h3><h3 id="如何解决-post-请求中文乱码问题-get-的又如何处理呢" tabindex="-1"><a class="header-anchor" href="#如何解决-post-请求中文乱码问题-get-的又如何处理呢"><span>如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？</span></a></h3><h3 id="springmvc-的控制器是不是单例模式-如果是会有什么问题-怎么解决" tabindex="-1"><a class="header-anchor" href="#springmvc-的控制器是不是单例模式-如果是会有什么问题-怎么解决"><span>SpringMVC 的控制器是不是单例模式，如果是会有什么问题，怎么解决？</span></a></h3><h3 id="springmvc-怎么样设定重定向和转发的" tabindex="-1"><a class="header-anchor" href="#springmvc-怎么样设定重定向和转发的"><span>SpringMVC 怎么样设定重定向和转发的？</span></a></h3><h3 id="springmvc-里面拦截器是怎么写的" tabindex="-1"><a class="header-anchor" href="#springmvc-里面拦截器是怎么写的"><span>SpringMVC 里面拦截器是怎么写的？</span></a></h3><h3 id="springmvc-和-struts2-的区别有哪些" tabindex="-1"><a class="header-anchor" href="#springmvc-和-struts2-的区别有哪些"><span>SpringMVC 和 Struts2 的区别有哪些?</span></a></h3><h3 id="谈谈你对-mybatis-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-mybatis-的理解"><span>谈谈你对 MyBatis 的理解？</span></a></h3><h3 id="mybaits-的优缺点有哪些" tabindex="-1"><a class="header-anchor" href="#mybaits-的优缺点有哪些"><span>MyBaits 的优缺点有哪些？</span></a></h3><h3 id="mybatis-与-hibernate-有哪些不同" tabindex="-1"><a class="header-anchor" href="#mybatis-与-hibernate-有哪些不同"><span>MyBatis 与 Hibernate 有哪些不同？</span></a></h3><h3 id="mybatis-中-和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#mybatis-中-和-的区别是什么"><span>MyBatis 中 #{} 和 \${}的区别是什么？</span></a></h3><h3 id="mybatis-是如何进行分页的-分页插件的原理是什么" tabindex="-1"><a class="header-anchor" href="#mybatis-是如何进行分页的-分页插件的原理是什么"><span>MyBatis 是如何进行分页的？分页插件的原理是什么？</span></a></h3><h3 id="mybatis-有几种分页方式" tabindex="-1"><a class="header-anchor" href="#mybatis-有几种分页方式"><span>MyBatis 有几种分页方式？</span></a></h3><h3 id="mybatis-逻辑分页和物理分页的区别是什么" tabindex="-1"><a class="header-anchor" href="#mybatis-逻辑分页和物理分页的区别是什么"><span>MyBatis 逻辑分页和物理分页的区别是什么？</span></a></h3><h3 id="mybatis-是否支持延迟加载-如果支持-它的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#mybatis-是否支持延迟加载-如果支持-它的实现原理是什么"><span>MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</span></a></h3><h3 id="说一下-mybatis-的一级缓存和二级缓存" tabindex="-1"><a class="header-anchor" href="#说一下-mybatis-的一级缓存和二级缓存"><span>说一下 MyBatis 的一级缓存和二级缓存？</span></a></h3><h3 id="mybatis-有哪些执行器-executor" tabindex="-1"><a class="header-anchor" href="#mybatis-有哪些执行器-executor"><span>Mybatis 有哪些执行器（Executor）？</span></a></h3><h3 id="mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql的执行原理不" tabindex="-1"><a class="header-anchor" href="#mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql的执行原理不"><span>MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL的执行原理不？</span></a></h3><h3 id="答案在我整理的一本《java面试八股文》pdf里都有-如果需要可以直接点击获取。" tabindex="-1"><a class="header-anchor" href="#答案在我整理的一本《java面试八股文》pdf里都有-如果需要可以直接点击获取。"><span>答案在我整理的一本《Java面试八股文》PDF里都有，如果需要可以直接点击获取。</span></a></h3><h2 id="七、mysql-31-道" tabindex="-1"><a class="header-anchor" href="#七、mysql-31-道"><span>七、MySQL 31 道</span></a></h2><h3 id="请说下你对-mysql-架构的了解" tabindex="-1"><a class="header-anchor" href="#请说下你对-mysql-架构的了解"><span>请说下你对 MySQL 架构的了解？</span></a></h3><h3 id="一条-sql-语句在数据库框架中的执行流程" tabindex="-1"><a class="header-anchor" href="#一条-sql-语句在数据库框架中的执行流程"><span>一条 SQL 语句在数据库框架中的执行流程？</span></a></h3><h3 id="数据库的三范式是什么" tabindex="-1"><a class="header-anchor" href="#数据库的三范式是什么"><span>数据库的三范式是什么？</span></a></h3><h3 id="char-和-varchar-的区别" tabindex="-1"><a class="header-anchor" href="#char-和-varchar-的区别"><span>char 和 varchar 的区别？</span></a></h3><h3 id="varchar-10-和-varchar-20-的区别" tabindex="-1"><a class="header-anchor" href="#varchar-10-和-varchar-20-的区别"><span>varchar(10) 和 varchar(20) 的区别？</span></a></h3><h3 id="谈谈你对索引的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对索引的理解"><span>谈谈你对索引的理解？</span></a></h3><h3 id="索引的底层使用的是什么数据结构" tabindex="-1"><a class="header-anchor" href="#索引的底层使用的是什么数据结构"><span>索引的底层使用的是什么数据结构？</span></a></h3><h3 id="谈谈你对-b-树的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-b-树的理解"><span>谈谈你对 B+ 树的理解？</span></a></h3><h3 id="为什么-innodb-存储引擎选用-b-树而不是-b-树呢" tabindex="-1"><a class="header-anchor" href="#为什么-innodb-存储引擎选用-b-树而不是-b-树呢"><span>为什么 InnoDB 存储引擎选用 B+ 树而不是 B 树呢？</span></a></h3><h3 id="谈谈你对聚簇索引的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对聚簇索引的理解"><span>谈谈你对聚簇索引的理解？</span></a></h3><h3 id="谈谈你对哈希索引的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对哈希索引的理解"><span>谈谈你对哈希索引的理解？</span></a></h3><h3 id="谈谈你对覆盖索引的认识" tabindex="-1"><a class="header-anchor" href="#谈谈你对覆盖索引的认识"><span>谈谈你对覆盖索引的认识？</span></a></h3><h3 id="索引的分类" tabindex="-1"><a class="header-anchor" href="#索引的分类"><span>索引的分类？</span></a></h3><h3 id="谈谈你对最左前缀原则的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对最左前缀原则的理解"><span>谈谈你对最左前缀原则的理解？</span></a></h3><h3 id="怎么知道创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因" tabindex="-1"><a class="header-anchor" href="#怎么知道创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因"><span>怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?</span></a></h3><h3 id="什么情况下索引会失效-即查询不走索引" tabindex="-1"><a class="header-anchor" href="#什么情况下索引会失效-即查询不走索引"><span>什么情况下索引会失效？即查询不走索引？</span></a></h3><h3 id="查询性能的优化方法" tabindex="-1"><a class="header-anchor" href="#查询性能的优化方法"><span>查询性能的优化方法？</span></a></h3><h3 id="innodb-和-myisam-的比较" tabindex="-1"><a class="header-anchor" href="#innodb-和-myisam-的比较"><span>InnoDB 和 MyISAM 的比较？</span></a></h3><h3 id="谈谈你对水平切分和垂直切分的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对水平切分和垂直切分的理解"><span>谈谈你对水平切分和垂直切分的理解？</span></a></h3><h3 id="主从复制中涉及到哪三个线程" tabindex="-1"><a class="header-anchor" href="#主从复制中涉及到哪三个线程"><span>主从复制中涉及到哪三个线程？</span></a></h3><h3 id="主从同步的延迟原因及解决办法" tabindex="-1"><a class="header-anchor" href="#主从同步的延迟原因及解决办法"><span>主从同步的延迟原因及解决办法？</span></a></h3><h3 id="谈谈你对数据库读写分离的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对数据库读写分离的理解"><span>谈谈你对数据库读写分离的理解？</span></a></h3><h3 id="请你描述下事务的特性" tabindex="-1"><a class="header-anchor" href="#请你描述下事务的特性"><span>请你描述下事务的特性？</span></a></h3><h3 id="谈谈你对事务隔离级别的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对事务隔离级别的理解"><span>谈谈你对事务隔离级别的理解？</span></a></h3><h3 id="解释下什么叫脏读、不可重复读和幻读" tabindex="-1"><a class="header-anchor" href="#解释下什么叫脏读、不可重复读和幻读"><span>解释下什么叫脏读、不可重复读和幻读？</span></a></h3><h3 id="mysql-默认的隔离级别是什么" tabindex="-1"><a class="header-anchor" href="#mysql-默认的隔离级别是什么"><span>MySQL 默认的隔离级别是什么？</span></a></h3><h3 id="谈谈你对mvcc-的了解" tabindex="-1"><a class="header-anchor" href="#谈谈你对mvcc-的了解"><span>谈谈你对MVCC 的了解？</span></a></h3><h3 id="说一下-mysql-的行锁和表锁" tabindex="-1"><a class="header-anchor" href="#说一下-mysql-的行锁和表锁"><span>说一下 MySQL 的行锁和表锁？</span></a></h3><h3 id="innodb-存储引擎的锁的算法有哪些" tabindex="-1"><a class="header-anchor" href="#innodb-存储引擎的锁的算法有哪些"><span>InnoDB 存储引擎的锁的算法有哪些？</span></a></h3><h3 id="mysql-问题排查都有哪些手段" tabindex="-1"><a class="header-anchor" href="#mysql-问题排查都有哪些手段"><span>MySQL 问题排查都有哪些手段？</span></a></h3><h3 id="mysql-数据库-cpu-飙升到-500-的话他怎么处理" tabindex="-1"><a class="header-anchor" href="#mysql-数据库-cpu-飙升到-500-的话他怎么处理"><span>MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？</span></a></h3><h2 id="八、redis-12-道" tabindex="-1"><a class="header-anchor" href="#八、redis-12-道"><span>八、Redis 12 道</span></a></h2><h3 id="谈下你对-redis-的了解" tabindex="-1"><a class="header-anchor" href="#谈下你对-redis-的了解"><span>谈下你对 Redis 的了解？</span></a></h3><h3 id="redis-一般都有哪些使用场景" tabindex="-1"><a class="header-anchor" href="#redis-一般都有哪些使用场景"><span>Redis 一般都有哪些使用场景？</span></a></h3><h3 id="redis-有哪些常见的功能" tabindex="-1"><a class="header-anchor" href="#redis-有哪些常见的功能"><span>Redis 有哪些常见的功能？</span></a></h3><h3 id="redis-支持的数据类型有哪些" tabindex="-1"><a class="header-anchor" href="#redis-支持的数据类型有哪些"><span>Redis 支持的数据类型有哪些？</span></a></h3><h3 id="redis-为什么这么快" tabindex="-1"><a class="header-anchor" href="#redis-为什么这么快"><span>Redis 为什么这么快？</span></a></h3><h3 id="什么是缓存穿透-怎么解决" tabindex="-1"><a class="header-anchor" href="#什么是缓存穿透-怎么解决"><span>什么是缓存穿透？怎么解决？</span></a></h3><h3 id="什么是缓存雪崩-该如何解决" tabindex="-1"><a class="header-anchor" href="#什么是缓存雪崩-该如何解决"><span>什么是缓存雪崩？该如何解决？</span></a></h3><h3 id="怎么保证缓存和数据库数据的一致性" tabindex="-1"><a class="header-anchor" href="#怎么保证缓存和数据库数据的一致性"><span>怎么保证缓存和数据库数据的一致性？</span></a></h3><h3 id="redis-持久化有几种方式" tabindex="-1"><a class="header-anchor" href="#redis-持久化有几种方式"><span>Redis 持久化有几种方式？</span></a></h3><h3 id="redis-怎么实现分布式锁" tabindex="-1"><a class="header-anchor" href="#redis-怎么实现分布式锁"><span>Redis 怎么实现分布式锁？</span></a></h3><h3 id="redis-淘汰策略有哪些" tabindex="-1"><a class="header-anchor" href="#redis-淘汰策略有哪些"><span>Redis 淘汰策略有哪些？</span></a></h3><h3 id="redis-常见性能问题和解决方案" tabindex="-1"><a class="header-anchor" href="#redis-常见性能问题和解决方案"><span>Redis 常见性能问题和解决方案？</span></a></h3><h2 id="九、计算机网络-45-道" tabindex="-1"><a class="header-anchor" href="#九、计算机网络-45-道"><span>九、计算机网络 45 道</span></a></h2><h3 id="为什么需要三次握手-两次不行" tabindex="-1"><a class="header-anchor" href="#为什么需要三次握手-两次不行"><span>为什么需要三次握手？两次不行？</span></a></h3><h3 id="为什么需要四次挥手-三次不行" tabindex="-1"><a class="header-anchor" href="#为什么需要四次挥手-三次不行"><span>为什么需要四次挥手？三次不行？</span></a></h3><h3 id="tcp与udp有哪些区别-各自应用场景" tabindex="-1"><a class="header-anchor" href="#tcp与udp有哪些区别-各自应用场景"><span>TCP与UDP有哪些区别？各自应用场景？</span></a></h3><h3 id="http1-0-1-1-2-0-的版本区别" tabindex="-1"><a class="header-anchor" href="#http1-0-1-1-2-0-的版本区别"><span>HTTP1.0，1.1，2.0 的版本区别</span></a></h3><h3 id="post和get有哪些区别-各自应用场景" tabindex="-1"><a class="header-anchor" href="#post和get有哪些区别-各自应用场景"><span>POST和GET有哪些区别？各自应用场景？</span></a></h3><h3 id="http-哪些常用的状态码及使用场景" tabindex="-1"><a class="header-anchor" href="#http-哪些常用的状态码及使用场景"><span>HTTP 哪些常用的状态码及使用场景？</span></a></h3><h3 id="http状态码301和302的区别-都有哪些用途" tabindex="-1"><a class="header-anchor" href="#http状态码301和302的区别-都有哪些用途"><span>HTTP状态码301和302的区别，都有哪些用途？</span></a></h3><h3 id="在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持" tabindex="-1"><a class="header-anchor" href="#在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持"><span>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</span></a></h3><h3 id="http-如何实现长连接-在什么时候会超时" tabindex="-1"><a class="header-anchor" href="#http-如何实现长连接-在什么时候会超时"><span>HTTP 如何实现长连接？在什么时候会超时？</span></a></h3><h3 id="tcp-如何保证有效传输及拥塞控制原理" tabindex="-1"><a class="header-anchor" href="#tcp-如何保证有效传输及拥塞控制原理"><span>TCP 如何保证有效传输及拥塞控制原理</span></a></h3><h3 id="ip地址有哪些分类" tabindex="-1"><a class="header-anchor" href="#ip地址有哪些分类"><span>IP地址有哪些分类？</span></a></h3><h3 id="get请求中url编码的意义" tabindex="-1"><a class="header-anchor" href="#get请求中url编码的意义"><span>GET请求中URL编码的意义</span></a></h3><h3 id="什么是sql-注入-举个例子" tabindex="-1"><a class="header-anchor" href="#什么是sql-注入-举个例子"><span>什么是SQL 注入？举个例子？</span></a></h3><h3 id="谈一谈-xss-攻击-举个例子" tabindex="-1"><a class="header-anchor" href="#谈一谈-xss-攻击-举个例子"><span>谈一谈 XSS 攻击，举个例子？</span></a></h3><h3 id="讲一下网络五层模型-每一层的职责" tabindex="-1"><a class="header-anchor" href="#讲一下网络五层模型-每一层的职责"><span>讲一下网络五层模型，每一层的职责？</span></a></h3><h3 id="简单说下-https-和-http-的区别" tabindex="-1"><a class="header-anchor" href="#简单说下-https-和-http-的区别"><span>简单说下 HTTPS 和 HTTP 的区别</span></a></h3><h3 id="对称加密与非对称加密的区别" tabindex="-1"><a class="header-anchor" href="#对称加密与非对称加密的区别"><span>对称加密与非对称加密的区别</span></a></h3><h3 id="简单说下每一层对应的网络协议有哪些" tabindex="-1"><a class="header-anchor" href="#简单说下每一层对应的网络协议有哪些"><span>简单说下每一层对应的网络协议有哪些？</span></a></h3><h3 id="arp-协议的工作原理" tabindex="-1"><a class="header-anchor" href="#arp-协议的工作原理"><span>ARP 协议的工作原理？</span></a></h3><h3 id="tcp-的主要特点是什么" tabindex="-1"><a class="header-anchor" href="#tcp-的主要特点是什么"><span>TCP 的主要特点是什么？</span></a></h3><h3 id="udp-的主要特点是什么" tabindex="-1"><a class="header-anchor" href="#udp-的主要特点是什么"><span>UDP 的主要特点是什么？</span></a></h3><h3 id="tcp-和-udp-分别对应的常见应用层协议有哪些" tabindex="-1"><a class="header-anchor" href="#tcp-和-udp-分别对应的常见应用层协议有哪些"><span>TCP 和 UDP 分别对应的常见应用层协议有哪些？</span></a></h3><h3 id="为什么-time-wait-状态必须等待-2msl-的时间呢" tabindex="-1"><a class="header-anchor" href="#为什么-time-wait-状态必须等待-2msl-的时间呢"><span>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</span></a></h3><h3 id="保活计时器的作用" tabindex="-1"><a class="header-anchor" href="#保活计时器的作用"><span>保活计时器的作用？</span></a></h3><h3 id="tcp-协议是如何保证可靠传输的" tabindex="-1"><a class="header-anchor" href="#tcp-协议是如何保证可靠传输的"><span>TCP 协议是如何保证可靠传输的？</span></a></h3><h3 id="谈谈你对停止等待协议的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对停止等待协议的理解"><span>谈谈你对停止等待协议的理解？</span></a></h3><h3 id="谈谈你对-arq-协议的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-arq-协议的理解"><span>谈谈你对 ARQ 协议的理解？</span></a></h3><h3 id="谈谈你对滑动窗口的了解" tabindex="-1"><a class="header-anchor" href="#谈谈你对滑动窗口的了解"><span>谈谈你对滑动窗口的了解？</span></a></h3><h3 id="谈下你对流量控制的理解" tabindex="-1"><a class="header-anchor" href="#谈下你对流量控制的理解"><span>谈下你对流量控制的理解？</span></a></h3><h3 id="谈下你对-tcp-拥塞控制的理解-使用了哪些算法" tabindex="-1"><a class="header-anchor" href="#谈下你对-tcp-拥塞控制的理解-使用了哪些算法"><span>谈下你对 TCP 拥塞控制的理解？使用了哪些算法？</span></a></h3><h3 id="什么是粘包" tabindex="-1"><a class="header-anchor" href="#什么是粘包"><span>什么是粘包？</span></a></h3><h3 id="tcp-黏包是怎么产生的" tabindex="-1"><a class="header-anchor" href="#tcp-黏包是怎么产生的"><span>TCP 黏包是怎么产生的？</span></a></h3><h3 id="怎么解决拆包和粘包" tabindex="-1"><a class="header-anchor" href="#怎么解决拆包和粘包"><span>怎么解决拆包和粘包？</span></a></h3><h3 id="forward-和-redirect-的区别" tabindex="-1"><a class="header-anchor" href="#forward-和-redirect-的区别"><span>forward 和 redirect 的区别？</span></a></h3><h3 id="http-方法有哪些" tabindex="-1"><a class="header-anchor" href="#http-方法有哪些"><span>HTTP 方法有哪些？</span></a></h3><h3 id="在浏览器中输入-url-地址到显示主页的过程" tabindex="-1"><a class="header-anchor" href="#在浏览器中输入-url-地址到显示主页的过程"><span>在浏览器中输入 URL 地址到显示主页的过程？</span></a></h3><h3 id="dns-的解析过程" tabindex="-1"><a class="header-anchor" href="#dns-的解析过程"><span>DNS 的解析过程？</span></a></h3><h3 id="谈谈你对域名缓存的了解" tabindex="-1"><a class="header-anchor" href="#谈谈你对域名缓存的了解"><span>谈谈你对域名缓存的了解？</span></a></h3><h3 id="谈下你对-http-长连接和短连接的理解-分别应用于哪些场景" tabindex="-1"><a class="header-anchor" href="#谈下你对-http-长连接和短连接的理解-分别应用于哪些场景"><span>谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</span></a></h3><h3 id="https-的工作过程" tabindex="-1"><a class="header-anchor" href="#https-的工作过程"><span>HTTPS 的工作过程？</span></a></h3><h3 id="http-和-https-的区别" tabindex="-1"><a class="header-anchor" href="#http-和-https-的区别"><span>HTTP 和 HTTPS 的区别？</span></a></h3><h3 id="https-的优缺点" tabindex="-1"><a class="header-anchor" href="#https-的优缺点"><span>HTTPS 的优缺点？</span></a></h3><h3 id="什么是数字签名" tabindex="-1"><a class="header-anchor" href="#什么是数字签名"><span>什么是数字签名？</span></a></h3><h3 id="什么是数字证书" tabindex="-1"><a class="header-anchor" href="#什么是数字证书"><span>什么是数字证书？</span></a></h3><h3 id="cookie-和-session-有什么区别" tabindex="-1"><a class="header-anchor" href="#cookie-和-session-有什么区别"><span>Cookie 和 Session 有什么区别？</span></a></h3><h2 id="十、操作系统-32-道" tabindex="-1"><a class="header-anchor" href="#十、操作系统-32-道"><span>十、操作系统 32 道</span></a></h2><h3 id="简单说下你对并发和并行的理解" tabindex="-1"><a class="header-anchor" href="#简单说下你对并发和并行的理解"><span>简单说下你对并发和并行的理解？</span></a></h3><h3 id="同步、异步、阻塞、非阻塞的概念" tabindex="-1"><a class="header-anchor" href="#同步、异步、阻塞、非阻塞的概念"><span>同步、异步、阻塞、非阻塞的概念</span></a></h3><h3 id="进程和线程的基本概念" tabindex="-1"><a class="header-anchor" href="#进程和线程的基本概念"><span>进程和线程的基本概念</span></a></h3><h3 id="进程与线程的区别" tabindex="-1"><a class="header-anchor" href="#进程与线程的区别"><span>进程与线程的区别？</span></a></h3><h3 id="为什么有了进程-还要有线程呢" tabindex="-1"><a class="header-anchor" href="#为什么有了进程-还要有线程呢"><span>为什么有了进程，还要有线程呢？</span></a></h3><h3 id="进程的状态转换" tabindex="-1"><a class="header-anchor" href="#进程的状态转换"><span>进程的状态转换</span></a></h3><h3 id="进程间的通信方式有哪些" tabindex="-1"><a class="header-anchor" href="#进程间的通信方式有哪些"><span>进程间的通信方式有哪些？</span></a></h3><h3 id="进程的调度算法有哪些" tabindex="-1"><a class="header-anchor" href="#进程的调度算法有哪些"><span>进程的调度算法有哪些？</span></a></h3><h3 id="什么是死锁" tabindex="-1"><a class="header-anchor" href="#什么是死锁"><span>什么是死锁？</span></a></h3><h3 id="产生死锁的原因" tabindex="-1"><a class="header-anchor" href="#产生死锁的原因"><span>产生死锁的原因？</span></a></h3><h3 id="死锁产生的必要条件" tabindex="-1"><a class="header-anchor" href="#死锁产生的必要条件"><span>死锁产生的必要条件？</span></a></h3><h3 id="解决死锁的基本方法" tabindex="-1"><a class="header-anchor" href="#解决死锁的基本方法"><span>解决死锁的基本方法？</span></a></h3><h3 id="怎么预防死锁" tabindex="-1"><a class="header-anchor" href="#怎么预防死锁"><span>怎么预防死锁？</span></a></h3><h3 id="怎么避免死锁" tabindex="-1"><a class="header-anchor" href="#怎么避免死锁"><span>怎么避免死锁？</span></a></h3><h3 id="怎么解除死锁" tabindex="-1"><a class="header-anchor" href="#怎么解除死锁"><span>怎么解除死锁？</span></a></h3><h3 id="什么是缓冲区溢出-有什么危害" tabindex="-1"><a class="header-anchor" href="#什么是缓冲区溢出-有什么危害"><span>什么是缓冲区溢出？有什么危害？</span></a></h3><h3 id="分页与分段的区别" tabindex="-1"><a class="header-anchor" href="#分页与分段的区别"><span>分页与分段的区别？</span></a></h3><h3 id="物理地址、逻辑地址、虚拟内存的概念" tabindex="-1"><a class="header-anchor" href="#物理地址、逻辑地址、虚拟内存的概念"><span>物理地址、逻辑地址、虚拟内存的概念</span></a></h3><h3 id="页面置换算法有哪些" tabindex="-1"><a class="header-anchor" href="#页面置换算法有哪些"><span>页面置换算法有哪些？</span></a></h3><h3 id="谈谈你对动态链接库和静态链接库的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对动态链接库和静态链接库的理解"><span>谈谈你对动态链接库和静态链接库的理解？</span></a></h3><h3 id="外中断和异常有什么区别" tabindex="-1"><a class="header-anchor" href="#外中断和异常有什么区别"><span>外中断和异常有什么区别？</span></a></h3><h3 id="一个程序从开始运行到结束的完整过程-你能说出来多少" tabindex="-1"><a class="header-anchor" href="#一个程序从开始运行到结束的完整过程-你能说出来多少"><span>一个程序从开始运行到结束的完整过程，你能说出来多少？</span></a></h3><h3 id="什么是用户态和内核态" tabindex="-1"><a class="header-anchor" href="#什么是用户态和内核态"><span>什么是用户态和内核态</span></a></h3><h3 id="用户态和内核态是如何切换的" tabindex="-1"><a class="header-anchor" href="#用户态和内核态是如何切换的"><span>用户态和内核态是如何切换的？</span></a></h3><h3 id="进程终止的方式" tabindex="-1"><a class="header-anchor" href="#进程终止的方式"><span>进程终止的方式</span></a></h3><h3 id="守护进程、僵尸进程和孤儿进程" tabindex="-1"><a class="header-anchor" href="#守护进程、僵尸进程和孤儿进程"><span>守护进程、僵尸进程和孤儿进程</span></a></h3><h3 id="如何避免僵尸进程" tabindex="-1"><a class="header-anchor" href="#如何避免僵尸进程"><span>如何避免僵尸进程？</span></a></h3><h3 id="介绍一下几种典型的锁" tabindex="-1"><a class="header-anchor" href="#介绍一下几种典型的锁"><span>介绍一下几种典型的锁？</span></a></h3><h3 id="常见内存分配内存错误" tabindex="-1"><a class="header-anchor" href="#常见内存分配内存错误"><span>常见内存分配内存错误</span></a></h3><h3 id="内存交换中-被换出的进程保存在哪里" tabindex="-1"><a class="header-anchor" href="#内存交换中-被换出的进程保存在哪里"><span>内存交换中，被换出的进程保存在哪里？</span></a></h3><h3 id="原子操作的是如何实现的" tabindex="-1"><a class="header-anchor" href="#原子操作的是如何实现的"><span>原子操作的是如何实现的</span></a></h3><h3 id="抖动你知道是什么吗-它也叫颠簸现象" tabindex="-1"><a class="header-anchor" href="#抖动你知道是什么吗-它也叫颠簸现象"><span>抖动你知道是什么吗？它也叫颠簸现象</span></a></h3><h2 id="十一、消息队列与分布式-26-道" tabindex="-1"><a class="header-anchor" href="#十一、消息队列与分布式-26-道"><span>十一、消息队列与分布式 26 道</span></a></h2><h3 id="消息队列的基本作用" tabindex="-1"><a class="header-anchor" href="#消息队列的基本作用"><span>消息队列的基本作用？</span></a></h3><h3 id="消息队列的优缺点有哪些" tabindex="-1"><a class="header-anchor" href="#消息队列的优缺点有哪些"><span>消息队列的优缺点有哪些？</span></a></h3><h3 id="如何保证消息队列的高可用" tabindex="-1"><a class="header-anchor" href="#如何保证消息队列的高可用"><span>如何保证消息队列的高可用？</span></a></h3><h3 id="如何保证消息不被重复消费-或者说-如何保证消息消费的幂等性" tabindex="-1"><a class="header-anchor" href="#如何保证消息不被重复消费-或者说-如何保证消息消费的幂等性"><span>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</span></a></h3><h3 id="如何保证消息的可靠性传输-或者说-如何处理消息丢失的问题" tabindex="-1"><a class="header-anchor" href="#如何保证消息的可靠性传输-或者说-如何处理消息丢失的问题"><span>如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</span></a></h3><h3 id="如何保证消息的顺序性" tabindex="-1"><a class="header-anchor" href="#如何保证消息的顺序性"><span>如何保证消息的顺序性？</span></a></h3><h3 id="大量消息在-mq-里长时间积压-该如何解决" tabindex="-1"><a class="header-anchor" href="#大量消息在-mq-里长时间积压-该如何解决"><span>大量消息在 MQ 里长时间积压，该如何解决？</span></a></h3><h3 id="mq-中的消息过期失效了怎么办" tabindex="-1"><a class="header-anchor" href="#mq-中的消息过期失效了怎么办"><span>MQ 中的消息过期失效了怎么办？</span></a></h3><h3 id="rabbitmq-有哪些重要的角色" tabindex="-1"><a class="header-anchor" href="#rabbitmq-有哪些重要的角色"><span>RabbitMQ 有哪些重要的角色？</span></a></h3><h3 id="rabbitmq-有哪些重要的组件" tabindex="-1"><a class="header-anchor" href="#rabbitmq-有哪些重要的组件"><span>RabbitMQ 有哪些重要的组件？</span></a></h3><h3 id="rabbitmq-有几种广播类型" tabindex="-1"><a class="header-anchor" href="#rabbitmq-有几种广播类型"><span>RabbitMQ 有几种广播类型？</span></a></h3><h3 id="kafka-可以脱离-zookeeper-单独使用吗-为什么" tabindex="-1"><a class="header-anchor" href="#kafka-可以脱离-zookeeper-单独使用吗-为什么"><span>Kafka 可以脱离 zookeeper 单独使用吗？为什么？</span></a></h3><h3 id="kafka-有几种数据保留的策略" tabindex="-1"><a class="header-anchor" href="#kafka-有几种数据保留的策略"><span>Kafka 有几种数据保留的策略？</span></a></h3><h3 id="kafka-的分区策略有哪些" tabindex="-1"><a class="header-anchor" href="#kafka-的分区策略有哪些"><span>Kafka 的分区策略有哪些？</span></a></h3><h3 id="谈下你对-zookeeper-的认识" tabindex="-1"><a class="header-anchor" href="#谈下你对-zookeeper-的认识"><span>谈下你对 Zookeeper 的认识？</span></a></h3><h3 id="zookeeper-都有哪些功能" tabindex="-1"><a class="header-anchor" href="#zookeeper-都有哪些功能"><span>Zookeeper 都有哪些功能？</span></a></h3><h3 id="谈下你对-zab-协议的了解" tabindex="-1"><a class="header-anchor" href="#谈下你对-zab-协议的了解"><span>谈下你对 ZAB 协议的了解？</span></a></h3><h3 id="zookeeper-怎么保证主从节点的状态同步" tabindex="-1"><a class="header-anchor" href="#zookeeper-怎么保证主从节点的状态同步"><span>Zookeeper 怎么保证主从节点的状态同步？</span></a></h3><h3 id="zookeeper-有几种部署模式" tabindex="-1"><a class="header-anchor" href="#zookeeper-有几种部署模式"><span>Zookeeper 有几种部署模式？</span></a></h3><h3 id="说一下-zookeeper-的通知机制" tabindex="-1"><a class="header-anchor" href="#说一下-zookeeper-的通知机制"><span>说一下 Zookeeper 的通知机制？</span></a></h3><h3 id="集群中为什么要有主节点" tabindex="-1"><a class="header-anchor" href="#集群中为什么要有主节点"><span>集群中为什么要有主节点？</span></a></h3><h3 id="集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗" tabindex="-1"><a class="header-anchor" href="#集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗"><span>集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？</span></a></h3><h3 id="说一下两阶段提交和三阶段提交的过程-分别有什么问题" tabindex="-1"><a class="header-anchor" href="#说一下两阶段提交和三阶段提交的过程-分别有什么问题"><span>说一下两阶段提交和三阶段提交的过程？分别有什么问题？</span></a></h3><h3 id="zookeeper-宕机如何处理" tabindex="-1"><a class="header-anchor" href="#zookeeper-宕机如何处理"><span>Zookeeper 宕机如何处理？</span></a></h3><h3 id="说下四种类型的数据节点-znode" tabindex="-1"><a class="header-anchor" href="#说下四种类型的数据节点-znode"><span>说下四种类型的数据节点 Znode？</span></a></h3><h3 id="zookeeper-和-dubbo-的关系" tabindex="-1"><a class="header-anchor" href="#zookeeper-和-dubbo-的关系"><span>Zookeeper 和 Dubbo 的关系？</span></a></h3>`,455)])])}const y=s(k,[["render",o]]),A=JSON.parse('{"path":"/posts/interview/eight-legged-essay-java.html","title":"Java 八股文","lang":"zh-CN","frontmatter":{"icon":"lock","date":"2022-05-19T00:00:00.000Z","category":["面试"],"tag":["Java","Spring","Redis","MQ","计算机网络"],"feed":false,"seo":false,"head":[]},"git":{"createdTime":1653376909000,"updatedTime":1655458117000,"contributors":[{"name":"zJiaC","username":"zJiaC","email":"jc456123","commits":10,"url":"https://github.com/zJiaC"}]},"readingTime":{"minutes":44.07,"words":13220},"filePathRelative":"posts/interview/eight-legged-essay-java.md"}');export{y as comp,A as data};
