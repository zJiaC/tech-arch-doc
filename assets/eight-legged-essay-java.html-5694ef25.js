import{_ as t,X as r,Y as h,a0 as a,a2 as e,$ as s,a3 as i,I as d}from"./framework-31857947.js";const l="/tech-arch-doc/images/java-io-byte.png",c="/tech-arch-doc/images/java-io-character.png",o="/tech-arch-doc/images/Java集合容器.jpg",u="/tech-arch-doc/images/hashmap-put-1.7.webp",p="/tech-arch-doc/images/hashmap-put-1.8.webp",b="/tech-arch-doc/images/hashmap-get-1.7.webp",k="/tech-arch-doc/images/hashmap-get-1.8.webp",f={},m=a("h1",{id:"java-八股文",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#java-八股文","aria-hidden":"true"},"#"),e(" Java 八股文")],-1),x=a("h2",{id:"一、java基础-44-道",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#一、java基础-44-道","aria-hidden":"true"},"#"),e(" 一、Java基础 44 道")],-1),v={id:"解释下什么是面向对象-面向对象和面向过程的区别",tabindex:"-1"},y=a("a",{class:"header-anchor",href:"#解释下什么是面向对象-面向对象和面向过程的区别","aria-hidden":"true"},"#",-1),g={href:"http://web.suda.edu.cn/hejun/local_csharp/chapter1/csharp_1_3.html#python1",target:"_blank",rel:"noopener noreferrer"},w=i("<table><thead><tr><th>项目名称</th><th>面向对象程序设计</th><th>面向过程程序设计（也叫结构化编程）</th></tr></thead><tbody><tr><td>定义</td><td>面向对象顾名思义就是把现实中的事务都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，是一种“自下而上”的设计语言，先设计组件，再完成拼装。</td><td>面向过程是“自上而下”的设计语言，先定好框架，再增砖添瓦。通俗点，就是先定好main()函数，然后再逐步实现mian()函数中所要用到的其他方法。</td></tr><tr><td>特点</td><td>封装、继承、多态</td><td>算法+数据结构</td></tr><tr><td>优势</td><td>适用于大型复杂系统，方便复用、</td><td>适用于简单系统，容易理解</td></tr><tr><td>劣势</td><td>比较抽象、性能比面向过程低</td><td>难以应对复杂系统，难以复用，不易维护、不易扩展</td></tr><tr><td>对比</td><td>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td><td>性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</td></tr><tr><td>设计语言</td><td>Java、Smalltalk、EIFFEL、C++、Objective-、C#、Python等</td><td>C、Fortran</td></tr></tbody></table>",1),S={id:"面向对象的三大特性-分别解释下",tabindex:"-1"},_=a("a",{class:"header-anchor",href:"#面向对象的三大特性-分别解释下","aria-hidden":"true"},"#",-1),j={href:"http://web.suda.edu.cn/hejun/local_csharp/chapter1/csharp_1_3.html#python1",target:"_blank",rel:"noopener noreferrer"},q=i('<ul><li><p>封装</p><blockquote><p>两层含义：一层含义是把对象的属性和行为看成一个密不可分的整体，将这两者“封装”在一个不可分割的独立单元(即对象)中； 另一层含义指“信息隐藏”，把不需要让外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改， 而另一些属性或行为，则不允许外界知晓，或只允许使用对象的功能，而尽可能隐藏对象的功能实现细节。</p></blockquote><ul><li>优点 <ul><li>良好的封装能够减少耦合，符合程序设计追求“高内聚，低耦合”。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息实现细节。</li></ul></li></ul></li><li><p>继承</p><blockquote><p>继承是面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p></blockquote><ul><li>优点 <ul><li>提高类代码的复用性</li><li>提高了代码的维护性</li><li>使得类和类产生了关系，是多态的前提(它也是继承的一个弊端，类的耦合性提高了)</li></ul></li></ul></li><li><p>多态</p><blockquote><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p></blockquote></li></ul><h3 id="jdk、jre、jvm-三者之间的关系" tabindex="-1"><a class="header-anchor" href="#jdk、jre、jvm-三者之间的关系" aria-hidden="true">#</a> JDK、JRE、JVM 三者之间的关系？</h3><ul><li>JDK（Java Development Kit） <ul><li>是针对Java开发员的产品，是整个Java的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。</li></ul></li><li>JRE（Java Runtime Environment） <ul><li>是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。</li></ul></li><li>JVM（Java Virtual Machine） <ul><li>是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。</li></ul></li></ul><h3 id="重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#重载和重写的区别" aria-hidden="true">#</a> 重载和重写的区别？</h3><ul><li>重写(Override) <ul><li>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</li><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li></ul></li><li>重载(Overload) <ul><li>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</li><li>应该注意的是，返回值不同，其它都相同不算是重载。</li></ul></li></ul><h3 id="java-中是否可以重写一个-private-或者-static-方法" tabindex="-1"><a class="header-anchor" href="#java-中是否可以重写一个-private-或者-static-方法" aria-hidden="true">#</a> Java 中是否可以重写一个 private 或者 static 方法？</h3><ul><li>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。</li><li>static 方法类的任何实例都不相关，所以概念上不适用。</li><li>Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。</li></ul><h3 id="构造方法有哪些特性" tabindex="-1"><a class="header-anchor" href="#构造方法有哪些特性" aria-hidden="true">#</a> 构造方法有哪些特性？</h3><ul><li>构造方法名一定与类同名。</li><li>构造方法无返回值。</li><li>构造方法可以没有（默认一个无参构造方法），也可以有多个构造方法。他们之间构成重载关系。</li><li>如果定义有参构造函数，则无参构造函数将被自动屏蔽。</li><li>构造方法不能被继承。</li><li>构造方法不能手动调用，在创建类实例的时候自动调用构造方法。</li></ul><h3 id="在-java-中定义一个不做事且没有参数的构造方法有什么作用" tabindex="-1"><a class="header-anchor" href="#在-java-中定义一个不做事且没有参数的构造方法有什么作用" aria-hidden="true">#</a> 在 Java 中定义一个不做事且没有参数的构造方法有什么作用？</h3><ul><li>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</li><li>如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误。</li><li>Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</li></ul><h3 id="java-中创建对象的几种方式" tabindex="-1"><a class="header-anchor" href="#java-中创建对象的几种方式" aria-hidden="true">#</a> Java 中创建对象的几种方式？</h3><ul><li>使用 new 关键字：这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的够赞函数（无参的和有参的）。比如：Student student = new Student();</li><li>使用 Class 类的 newInstance 方法：我们也可以使用 Class 类的 newInstance 方法创建对象，这个 newInstance 方法调用无参的构造器创建对象，如：Student student2 = (Student)Class.forName(&quot;根路径.Student&quot;).newInstance();　或者：Student stu = Student.class.newInstance();</li><li>使用 Constructor 类的 newInstance 方法：本方法和 Class 类的 newInstance 方法很像，java.lang.relect.Constructor 类里也有一个 newInstance 方法可以创建对象。我们可以通过这个 newInstance 方法调用有参数的和私有的构造函数。如： Constructor constructor =Student.class.getInstance(); Student stu = constructor.newInstance();　这两种 newInstance 的方法就是大家所说的反射，事实上 Class 的 newInstance 方法内部调用 Constructor 的 newInstance 方法。这也是众多框架 Spring、Hibernate、Struts 等使用后者的原因。</li><li>使用 Clone 的方法：无论何时我们调用一个对象的 clone 方法，JVM 就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用 clone 方法创建对象并不会调用任何构造函数。要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。如：Student stu2 = stu.clone();这也是原型模式的应用。</li><li>使用反序列化：当我们序列化和反序列化一个对象，JVM 会给我们创建一个单独的对象，在反序列化时，JVM 创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现 Serializable 接口。如：ObjectInputStream in = new ObjectInputStream (new FileInputStream(&quot;data.obj&quot;)); Student stu3 = (Student)in.readObject();</li></ul><h3 id="抽象类和接口有什么区别" tabindex="-1"><a class="header-anchor" href="#抽象类和接口有什么区别" aria-hidden="true">#</a> 抽象类和接口有什么区别？</h3><ul><li>抽象类中可以定义构造方法，而接口中不可以定义构造方法；</li><li>抽象类中可以有抽象方法和具体方法，而接口中只能有抽象方法（public abstract）；</li><li>抽象类中的成员权限可以是 public、默认（default）、protected（抽象类中的抽象方法就是为了重写，所以不能被 private 修饰），而接口中的成员只可以是 public（方法默认：public abstact，成员变量默认：public static final）；</li><li>抽象类中可以包含静态方法，而接口中不可以包含静态方法。</li></ul><h3 id="静态变量和实例变量的区别" tabindex="-1"><a class="header-anchor" href="#静态变量和实例变量的区别" aria-hidden="true">#</a> 静态变量和实例变量的区别？</h3><ul><li>静态变量前要加上关键字 static，实例变量则不会。</li><li>实例变量是属于某个对象的属性，必须创建了实例对象，其中的实例变量才会分配空间，才能使用这个实例变量。</li><li>静态变量不属于任何的实例对象，而是属于类，也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，就会被分配空间。</li><li>静态变量不需要创建任何的对象就可以直接使用，而实例变量需要先创建实例对象才能被使用。</li></ul><h3 id="_12、short-s1-1-s1-s1-1-有什么错-那么-short-s1-1-s1-1-呢-有没有错误" tabindex="-1"><a class="header-anchor" href="#_12、short-s1-1-s1-s1-1-有什么错-那么-short-s1-1-s1-1-呢-有没有错误" aria-hidden="true">#</a> 12、short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？</h3><ul><li>对于 short s1 = 1; s1 = s1 + 1; 由于 s1+1 运算时会自动提升表达式的类型，所以结果是 int 型，再赋值给 short 类型 s1 时，编译器将报告需要强制转换类型的错误。</li><li>对于 short s1 = 1; s1 += 1;由于 += 是 java 语言规定的运算符，java 编译器会对它进行特殊处理，因此可以正确编译。</li></ul><h3 id="integer-和-int-的区别" tabindex="-1"><a class="header-anchor" href="#integer-和-int-的区别" aria-hidden="true">#</a> Integer 和 int 的区别？</h3><ul><li>Integer 是 int 的包装类；int 是基本数据类型；</li><li>Integer 变量必须实例化后才能使用；int 变量不需要；</li><li>Integer 实际是对象的引用，指向此 new 的 Integer 对象；int 是直接存储数据值 ；</li><li>Integer 的默认值是 null；int 的默认值是0。</li></ul><h3 id="装箱和拆箱的区别" tabindex="-1"><a class="header-anchor" href="#装箱和拆箱的区别" aria-hidden="true">#</a> 装箱和拆箱的区别</h3><ul><li>装箱就是自动将基本数据类型转换为包装器类型</li><li>拆箱就是自动将包装器类型转换为基本数据类型</li></ul><h3 id="switch-语句能否作用在-byte-上-能否作用在-long-上-能否作用在-string-上" tabindex="-1"><a class="header-anchor" href="#switch-语句能否作用在-byte-上-能否作用在-long-上-能否作用在-string-上" aria-hidden="true">#</a> switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？</h3><ul><li>switch 可作用于 char byte short int</li><li>switch 可作用于 char byte short int 对应的包装类</li><li>switch 不可作用于 long double float boolean，包括他们的包装类</li><li>switch 中可以是字符串类型,String(JDK1.7 之后才可以作用在 string 上)</li><li>switch 中可以是枚举类型(JDK1.5 之后)</li></ul><h3 id="final、finally、finalize-的区别" tabindex="-1"><a class="header-anchor" href="#final、finally、finalize-的区别" aria-hidden="true">#</a> final、finally、finalize 的区别</h3><ul><li>final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.</li><li>finally 是异常处理语句结构的一部分，表示总是执行.</li><li>finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.</li></ul><h3 id="和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#和-equals-的区别" aria-hidden="true">#</a> == 和 equals 的区别？</h3><ul><li>对象类型不同 <ul><li>equals()：是超类 Object 中的方法。</li><li>==：是操作符。</li></ul></li><li>比较的对象不同 <ul><li>equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。</li><li>==：用于比较引用和比较基本数据类型时具有不同的功能，具体如下: <ul><li>基础数据类型：比较的是他们的值是否相等，比如两个 int 类型的变量，比较的是变量的值是否一样。</li><li>引用数据类型：比较的是引用的地址是否相同，比如说新建了两个 User 对象，比较的是两个 User 的地址是否一样。</li></ul></li></ul></li><li>运行速度不同 <ul><li>equals()：没有==运行速度快。</li><li>== 运行速度比 equals() 快，因为==只是比较引用。</li></ul></li></ul>',29),M={id:"两个对象的-hashcode-相同-则-equals-也一定为-true-吗",tabindex:"-1"},C=a("a",{class:"header-anchor",href:"#两个对象的-hashcode-相同-则-equals-也一定为-true-吗","aria-hidden":"true"},"#",-1),J={href:"https://www.modb.pro/db/105634",target:"_blank",rel:"noopener noreferrer"},H=i('<ul><li>Hashcode() 相等，equals() 可能相等，也可能不等。 <ul><li>假如这个类没有重写 equals 方法，如果两个对象值相同(x.equals(y) == true)，那么那么它们的hashCode值一定要相同；</li><li>如果重写 equals 方法，没有重写 HashCode 的方法，就会出现不相等的情况。</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>equals() 方法不相等的两个对象，Hashcode() 有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。 反过来，Hashcode() 不等，一定能推出 equals() 也不等；Hashcode() 相等，equals() 可能相等，也可能不等。</p></div><h3 id="为什么重写-equals-就一定要重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#为什么重写-equals-就一定要重写-hashcode-方法" aria-hidden="true">#</a> 为什么重写 equals() 就一定要重写 hashCode() 方法？</h3><ul><li>如果想完整的使用 HashSet 类 那么最少要重写 equals() 和 HashCode() 方法。 <ul><li>重写 HashCode() 用于获得元素的存储位置；</li><li>重写 equals() 用于在两个元素的位置相同的时候 比较两个元素是否相等。</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">原因分析</p><p>HashCode public int hashCode() 返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 Java.util.Hashtable 提供的哈希表）的性能。 HashCode 的常规协定是： 在 Java 应用程序执行期间，在对同一对象多次调用 HashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 HashCode 方法都必须生成相同的整数结果。 如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 HashCode 方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）</p><p>equals public boolean equals (Object obj) 指示其他某个对象是否与此对象“相等”。 equals 方法在非空对象引用上实现相等关系： 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。</p><p>对于任何非空引用值 x，x.equals(null) 都应返回 false。 Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。</p></div><h3 id="和-的区别" tabindex="-1"><a class="header-anchor" href="#和-的区别" aria-hidden="true">#</a> &amp; 和 &amp;&amp; 的区别？</h3><ul><li>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。 <ul><li>&amp;&amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式。</li></ul></li><li>&amp;还可以用作按位与的运算符，两个表达式的值按二进制位展开，对应的位 (bit) 按值进行“与”运算，结果保留在该位上</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1; 即：两位同时为“1”，结果才为“1”，否则为0 例如：3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001 ；因此，3&amp;5的值得1。</p></div><h3 id="java-中的参数传递时传值呢-还是传引用" tabindex="-1"><a class="header-anchor" href="#java-中的参数传递时传值呢-还是传引用" aria-hidden="true">#</a> Java 中的参数传递时传值呢？还是传引用？</h3>',9),E={href:"https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value",target:"_blank",rel:"noopener noreferrer"},I=i(`<h3 id="java-中的-math-round-1-5-等于多少" tabindex="-1"><a class="header-anchor" href="#java-中的-math-round-1-5-等于多少" aria-hidden="true">#</a> Java 中的 Math.round(-1.5) 等于多少？</h3><ul><li>Math.round(-1.5) 的返回值是 -1。四舍五入的原理是在参数上加 0.5 然后做向下取整。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> test <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">1.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//1</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">1.4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//1</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//2</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">1.6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//2</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">1.7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//2</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//-1</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//-1</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//-1</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//-2</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//-2</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="如何实现对象的克隆" tabindex="-1"><a class="header-anchor" href="#如何实现对象的克隆" aria-hidden="true">#</a> 如何实现对象的克隆？</h3><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone()方法.</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆.</li></ul><h3 id="深克隆和浅克隆的区别" tabindex="-1"><a class="header-anchor" href="#深克隆和浅克隆的区别" aria-hidden="true">#</a> 深克隆和浅克隆的区别？</h3><ul><li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li></ul><h3 id="什么是-java-的序列化-如何实现-java-的序列化" tabindex="-1"><a class="header-anchor" href="#什么是-java-的序列化-如何实现-java-的序列化" aria-hidden="true">#</a> 什么是 Java 的序列化，如何实现 Java 的序列化？</h3><ul><li>序列化：把 Java 对象转换为字节序列的过程。</li><li>反序列化：把字节序列恢复为 Java 对象的过程。</li></ul><h3 id="什么情况下需要序列化" tabindex="-1"><a class="header-anchor" href="#什么情况下需要序列化" aria-hidden="true">#</a> 什么情况下需要序列化？</h3><ul><li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li><li>在网络上传送对象的字节序列。</li></ul><h3 id="java-的泛型是如何工作的-什么是类型擦除" tabindex="-1"><a class="header-anchor" href="#java-的泛型是如何工作的-什么是类型擦除" aria-hidden="true">#</a> Java 的泛型是如何工作的 ? 什么是类型擦除 ?</h3><ul><li>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。</li><li>类型擦除:将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样</li></ul><h3 id="什么是泛型中的限定通配符和非限定通配符" tabindex="-1"><a class="header-anchor" href="#什么是泛型中的限定通配符和非限定通配符" aria-hidden="true">#</a> 什么是泛型中的限定通配符和非限定通配符 ?</h3><ul><li>限定通配符 <ul><li><code>&lt;? extends T&gt;</code> 它通过确保类型必须是T及T的子类来设定类型的上界。</li><li><code>&lt;? super T&gt;</code> 它通过确保类型必须是T及T的父类设定类型的下界。</li></ul></li><li>非限定通配符 <ul><li>类型为 <code>&lt;T&gt;</code>,可以用任意类型来替代。</li></ul></li></ul><h3 id="list-和-arraylist-之间有什么区别" tabindex="-1"><a class="header-anchor" href="#list-和-arraylist-之间有什么区别" aria-hidden="true">#</a> List 和 ArrayList 之间有什么区别 ?</h3><ul><li>List 是一个接口，而 ListArray 是一个类。</li><li>ListArray 继承并实现了 List。</li></ul><h3 id="java-中的反射是什么意思-有哪些应用场景" tabindex="-1"><a class="header-anchor" href="#java-中的反射是什么意思-有哪些应用场景" aria-hidden="true">#</a> Java 中的反射是什么意思？有哪些应用场景？</h3><blockquote><p>Java 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。 也就是说，反射本质上是一个“反着来”的过程。我们通过 new 创建一个类的实例时， 实际上是由 Java 虚拟机根据这个类的 Class 对象在运行时构建出来的， 而反射是通过一个类的 Class 对象来获取它的定义信息，从而我们可以访问到它的属性、方法， 知道这个类的父类、实现了哪些接口等信息。</p></blockquote><h3 id="反射的优缺点" tabindex="-1"><a class="header-anchor" href="#反射的优缺点" aria-hidden="true">#</a> 反射的优缺点？</h3><ul><li>优点 <ul><li>增加程序的灵活性，避免将程序写死到代码里。</li><li>代码简洁，提高代码的复用率，外部调用方便</li><li>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法</li></ul></li><li>缺点 <ul><li>性能问题</li><li>使用反射会模糊程序内部逻辑</li><li>安全限制</li><li>内部暴露</li></ul></li></ul><h3 id="java-中的动态代理是什么-有哪些应用" tabindex="-1"><a class="header-anchor" href="#java-中的动态代理是什么-有哪些应用" aria-hidden="true">#</a> Java 中的动态代理是什么？有哪些应用？</h3><ul><li>动态代理 <ul><li>动态代理是一种在运行时动态地创建代理对象，动态地处理代理方法调用的机制。</li><li>实际上它是一种代理机制。代理可以看做是对调用目标的一个封装，直接通过代理来实现对目标代码的调用。</li></ul></li><li>应用 <ul><li>Spring AOP 的动态代理实现</li><li>RPC 框架中的应用</li></ul></li></ul><h3 id="怎么实现动态代理" tabindex="-1"><a class="header-anchor" href="#怎么实现动态代理" aria-hidden="true">#</a> 怎么实现动态代理？</h3><ul><li>JDK 动态代理 <ul><li>利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。</li></ul></li><li>CGlib 动态代理 <ul><li>利用 ASM（开源的 Java 字节码编辑库，操作字节码）开源包，将代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。</li></ul></li><li>区别 <ul><li>JDK 代理只能对实现接口的类生成代理；CGlib 是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理 final 修饰的类。</li></ul></li></ul><h3 id="static-关键字的作用" tabindex="-1"><a class="header-anchor" href="#static-关键字的作用" aria-hidden="true">#</a> static 关键字的作用？</h3><ul><li>声明 <ul><li>静态变量</li><li>静态方法</li><li>静态语句块</li><li>静态内部类</li><li>静态导包</li></ul></li></ul><h3 id="super-关键字的作用" tabindex="-1"><a class="header-anchor" href="#super-关键字的作用" aria-hidden="true">#</a> super 关键字的作用？</h3><ul><li>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><h3 id="字节和字符的区别" tabindex="-1"><a class="header-anchor" href="#字节和字符的区别" aria-hidden="true">#</a> 字节和字符的区别？</h3><ul><li>字节(Byte)是计量单位，表示数据量多少，是计算机存储容量的计量单位。一个字节占8位。</li><li>字符(Character)计算机中使用的文字和符号，比如&#39;A&#39;、&#39;B&#39;、&#39;$&#39;、&#39;&amp;&#39;等。</li></ul>`,31),L={id:"string-为什么要设计为不可变类",tabindex:"-1"},T=a("a",{class:"header-anchor",href:"#string-为什么要设计为不可变类","aria-hidden":"true"},"#",-1),A={href:"https://www.pdai.tech/md/java/basic/java-basic-lan-basic.html#string",target:"_blank",rel:"noopener noreferrer"},z=i('<ul><li>可以缓存 hash 值</li><li>String Pool 的需要</li><li>安全性</li><li>线程安全</li></ul><h3 id="string、stringbuilder、stringbuffer-的区别" tabindex="-1"><a class="header-anchor" href="#string、stringbuilder、stringbuffer-的区别" aria-hidden="true">#</a> String、StringBuilder、StringBuffer 的区别？</h3><ul><li>可变性 <ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul></li><li>线程安全 <ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul></li></ul><h3 id="string-字符串修改实现的原理" tabindex="-1"><a class="header-anchor" href="#string-字符串修改实现的原理" aria-hidden="true">#</a> String 字符串修改实现的原理？</h3><ul><li>String 对象值是不可变的，一切操作都不会改变 String 的值，而是通过构造新的字符串来实现字符串操作。</li></ul><h3 id="string-str-i-与-string-str-new-string-i-一样吗" tabindex="-1"><a class="header-anchor" href="#string-str-i-与-string-str-new-string-i-一样吗" aria-hidden="true">#</a> String str = &quot;i&quot; 与 String str = new String(&quot;i&quot;) 一样吗？</h3><ul><li>不一样 <ul><li>使用String str=&quot;i&quot;，java虚拟机会把它分配到常量池中。</li><li>String str=new String(“i”)创建了一个对象，会被分到堆内存中。</li></ul></li></ul><h3 id="string-类的常用方法都有那些" tabindex="-1"><a class="header-anchor" href="#string-类的常用方法都有那些" aria-hidden="true">#</a> String 类的常用方法都有那些？</h3><ul><li>length() 字符串的长度</li><li>charAt() 截取一个字符</li><li>getChars() 截取多个字符</li><li>getBytes()</li><li>toCharArray()</li><li>equals() 和 equalsIgnoreCase()</li><li>regionMatches() <ul><li>用于比较一个字符串中特定区域与另一特定区域，它有一个重载的形式允许在比较中忽略大小写。</li></ul></li><li>startsWith()和endsWith()</li><li>equals() 和==</li><li>compareTo() 和 compareToIgnoreCase()</li><li>indexOf() 和 lastIndexOf()</li><li>substring()</li><li>concat() 连接两个字符串</li><li>replace() 替换</li><li>trim() 去掉起始和结尾的空格</li><li>valueOf()</li><li>toLowerCase()</li><li>toUpperCase()</li></ul><h3 id="final-修饰-stringbuffer-后还可以-append-吗" tabindex="-1"><a class="header-anchor" href="#final-修饰-stringbuffer-后还可以-append-吗" aria-hidden="true">#</a> final 修饰 StringBuffer 后还可以 append 吗？</h3><ul><li>可以 <ul><li>final 修饰的是一个引用变量，那么这个引用始终只能指向这个对象，但是这个对象内部的属性是可以变化的。</li></ul></li></ul><h3 id="java-中的-io-流的分类-说出几个你熟悉的实现类" tabindex="-1"><a class="header-anchor" href="#java-中的-io-流的分类-说出几个你熟悉的实现类" aria-hidden="true">#</a> Java 中的 IO 流的分类？说出几个你熟悉的实现类？</h3><ul><li>字节流 <img src="'+l+'" alt="java-io-byte"></li><li>字符流</li><li><img src="'+c+'" alt="java-io-character"></li></ul><h3 id="字节流和字符流有什么区别" tabindex="-1"><a class="header-anchor" href="#字节流和字符流有什么区别" aria-hidden="true">#</a> 字节流和字符流有什么区别？</h3><ul><li>字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节。)</li><li>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li><li>简而言之，字节是个计算机看的，字符才是给人看的。</li></ul><h3 id="bio、nio、aio-有什么区别" tabindex="-1"><a class="header-anchor" href="#bio、nio、aio-有什么区别" aria-hidden="true">#</a> BIO、NIO、AIO 有什么区别？</h3>',16),B={href:"http://java.io",target:"_blank",rel:"noopener noreferrer"},O=a("li",null,"NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序， 同时提供了更接近操作系统底层高性能的数据操作方式。",-1),D=a("li",null,"AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO）， 异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。",-1),P=i('<h2 id="二、java异常-9-道" tabindex="-1"><a class="header-anchor" href="#二、java异常-9-道" aria-hidden="true">#</a> 二、Java异常 9 道</h2><h3 id="finally-块中的代码什么时候被执行" tabindex="-1"><a class="header-anchor" href="#finally-块中的代码什么时候被执行" aria-hidden="true">#</a> finally 块中的代码什么时候被执行？</h3><ul><li>finally 不管有没有异常都要处理</li><li>当 try 和 catch 中有 return 时，finally 仍然会执行，finally 比 return 先执行</li><li>不管有木有异常抛出, finally 在 return 返回前执行</li><li>finally 是在 return 后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管 finally 中的代码怎么样， 返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在 finally 执行前确定的</li></ul><h3 id="finally-是不是一定会被执行到" tabindex="-1"><a class="header-anchor" href="#finally-是不是一定会被执行到" aria-hidden="true">#</a> finally 是不是一定会被执行到？</h3><ul><li>finally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值</li><li>finally 不执行的几种情况: 程序提前终止如调用了 System.exit, 病毒，断电</li></ul><h3 id="try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗" tabindex="-1"><a class="header-anchor" href="#try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗" aria-hidden="true">#</a> try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><ul><li>当 try 和 catch 中有 return 时，finally 仍然会执行，finally 比 return 先执行</li></ul><h3 id="try-catch-finally-中那个部分可以省略" tabindex="-1"><a class="header-anchor" href="#try-catch-finally-中那个部分可以省略" aria-hidden="true">#</a> try-catch-finally 中那个部分可以省略？</h3><ul><li>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</li></ul><h3 id="error-和-exception-的区别" tabindex="-1"><a class="header-anchor" href="#error-和-exception-的区别" aria-hidden="true">#</a> Error 和 Exception 的区别？</h3>',10),R={href:"https://www.pdai.tech/md/java/basic/java-basic-x-exception.html#error%E9%94%99%E8%AF%AF",target:"_blank",rel:"noopener noreferrer"},K={href:"https://www.pdai.tech/md/java/basic/java-basic-x-exception.html#exception%E5%BC%82%E5%B8%B8",target:"_blank",rel:"noopener noreferrer"},V=i('<h3 id="运行时异常与受检异常有何异同" tabindex="-1"><a class="header-anchor" href="#运行时异常与受检异常有何异同" aria-hidden="true">#</a> 运行时异常与受检异常有何异同？</h3><ul><li>运行时异常 (runtime exceptions), 需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除... <ul><li>常见的runtime exception: NullPointerException ArithmeticException ClassCastException IllegalArgumentException IllegalStateException IndexOutOfBoundsException NoSuchElementException</li></ul></li><li>受检查的异常(checked exceptions),其必须被try...catch语句块所捕获, 或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查, Java虚拟机也要进行检查, 以确保这个规则得到遵守。 <ul><li>常见的checked exception: ClassNotFoundException IOException FileNotFoundException EOFException</li></ul></li></ul><h3 id="throw-和-throws-的区别" tabindex="-1"><a class="header-anchor" href="#throw-和-throws-的区别" aria-hidden="true">#</a> throw 和 throws 的区别？</h3><ul><li>异常的申明 (throws) <ul><li>在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。</li></ul></li><li>异常的抛出 (throw) <ul><li>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。</li></ul></li></ul><h3 id="常见的异常类有哪些" tabindex="-1"><a class="header-anchor" href="#常见的异常类有哪些" aria-hidden="true">#</a> 常见的异常类有哪些？</h3><ul><li>常见的runtime exception: NullPointerException ArithmeticException ClassCastException IllegalArgumentException IllegalStateException IndexOutOfBoundsException NoSuchElementException</li></ul><h3 id="主线程可以捕获到子线程的异常吗" tabindex="-1"><a class="header-anchor" href="#主线程可以捕获到子线程的异常吗" aria-hidden="true">#</a> 主线程可以捕获到子线程的异常吗？</h3><ul><li>线程的问题应该线程自己本身来解决，而不要委托到外部。 <ul><li>特殊处理 <ul><li>子线程中 try... catch...</li><li>为线程设置 “未捕获异常处理器” UncaughtExceptionHandler</li><li>通过 Future 的 get 方法捕获异常（推荐</li></ul></li></ul></li></ul><h2 id="三、java集合-24-道" tabindex="-1"><a class="header-anchor" href="#三、java集合-24-道" aria-hidden="true">#</a> 三、Java集合 24 道</h2><h3 id="java-中常用的容器有哪些" tabindex="-1"><a class="header-anchor" href="#java-中常用的容器有哪些" aria-hidden="true">#</a> Java 中常用的容器有哪些？</h3><ul><li>ArrayList、LinkedList、Vector、HashSet、LinkedHashSet、TreeSet、LinkedHashMap、TreeMap、ConcurrentHashMap、Hashtable等等。 <img src="'+o+'" alt="Java集合容器"></li></ul><h3 id="arraylist-和-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#arraylist-和-linkedlist-的区别" aria-hidden="true">#</a> ArrayList 和 LinkedList 的区别？</h3><ul><li>ArrayList <ul><li>基于动态数组实现，支持随机访问。</li></ul></li><li>LinkedList <ul><li>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul></li></ul><h3 id="arraylist-实现-randomaccess-接口有何作用-为何-linkedlist-却没实现这个接口" tabindex="-1"><a class="header-anchor" href="#arraylist-实现-randomaccess-接口有何作用-为何-linkedlist-却没实现这个接口" aria-hidden="true">#</a> ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？</h3><ul><li>RandomAccess 是一个标记接口，内部是空的，标记“实现了这个接口的类支持快速（通常是固定时间）随机访问”。</li><li>LinkedList 没有实现 RandomAccess 接口，这是因为 LinkedList 存储数据的内存地址是不连续的，所以不支持随机访问。</li></ul><h3 id="arraylist-的扩容机制" tabindex="-1"><a class="header-anchor" href="#arraylist-的扩容机制" aria-hidden="true">#</a> ArrayList 的扩容机制？</h3><ul><li>ArrayList 是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。 所以在插入时候，会先检查是否需要扩容，如果当前容量 +1 超过数组长度，就会进行扩容。</li><li>ArrayList 的扩容是创建一个 1.5 倍的新数组，然后把原数组的值拷贝过去。</li><li></li></ul><h3 id="array-和-arraylist-有何区别-什么时候更适合用-array" tabindex="-1"><a class="header-anchor" href="#array-和-arraylist-有何区别-什么时候更适合用-array" aria-hidden="true">#</a> Array 和 ArrayList 有何区别？什么时候更适合用 Array？</h3><ul><li>Array：它是数组，申明数组的时候就要初始化并确定长度，长度不可变，而且它只能存储同一类型的数据，比如申明为 String 类型的数组，那么它只能存储 String 类型数据。</li><li>ArrayList：它是一个集合，需要先申明，然后再添加数据，长度是根据内容的多少而改变的，ArrayList 可以存放不同类型的数据，在存储基本类型数据的时候要使用基本数据类型的包装类。</li><li>当能确定长度并且数据类型一致的时候就可以用数组，其他时候使用ArrayList。</li></ul><h3 id="hashmap-的实现原理-底层数据结构-jdk1-7-和-jdk1-8" tabindex="-1"><a class="header-anchor" href="#hashmap-的实现原理-底层数据结构-jdk1-7-和-jdk1-8" aria-hidden="true">#</a> HashMap 的实现原理/底层数据结构？JDK1.7 和 JDK1.8</h3><ul><li>JDK 7 中，HashMap 由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li>在 JDK 8 中，HashMap 由“数组+链表+红黑树”组成。链表过长，会严重影响 HashMap 的性能，而红黑树搜索的时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK 8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换。</li></ul>',21),Q={id:"hashmap-的-put-方法的执行过程",tabindex:"-1"},F=a("a",{class:"header-anchor",href:"#hashmap-的-put-方法的执行过程","aria-hidden":"true"},"#",-1),N={href:"https://tobebetterjavaer.com/collection/hashmap-interview.html#_10%E3%80%81hashmap-%E7%9A%84put%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"},U=i('<ul><li>Java 1.7 <img src="'+u+'" alt="HashMap 的 put 流程"></li><li>Java 1.8 <img src="'+p+'" alt="HashMap 的 put 流程"></li></ul><h3 id="hashmap-的-get-方法的执行过程" tabindex="-1"><a class="header-anchor" href="#hashmap-的-get-方法的执行过程" aria-hidden="true">#</a> HashMap 的 get 方法的执行过程？</h3><ul><li>Java 1.7 <img src="'+b+'" alt="HashMap 的 get 流程"></li><li>Java 1.8 <img src="'+k+'" alt="HashMap 的 get 流程"></li></ul><h3 id="hashmap-的-resize-方法的执行过程" tabindex="-1"><a class="header-anchor" href="#hashmap-的-resize-方法的执行过程" aria-hidden="true">#</a> HashMap 的 resize 方法的执行过程？</h3><ul><li>初始化数组 table，并设置阈值。</li><li>数组容量翻倍，将元素迁移到新数组。</li></ul>',5),Z={id:"hashmap-的-size-为什么必须是-2-的整数次方",tabindex:"-1"},G=a("a",{class:"header-anchor",href:"#hashmap-的-size-为什么必须是-2-的整数次方","aria-hidden":"true"},"#",-1),W={href:"https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg",target:"_blank",rel:"noopener noreferrer"},$=i(`<h3 id="hashmap-多线程死循环问题" tabindex="-1"><a class="header-anchor" href="#hashmap-多线程死循环问题" aria-hidden="true">#</a> HashMap 多线程死循环问题？</h3><ul><li>多线程下扩容死循环。JDK1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li></ul><h3 id="hashmap-的-get-方法能否判断某个元素是否在-map-中" tabindex="-1"><a class="header-anchor" href="#hashmap-的-get-方法能否判断某个元素是否在-map-中" aria-hidden="true">#</a> HashMap 的 get 方法能否判断某个元素是否在 map 中？</h3><ul><li>HashMap 的 get 函数的返回值不能判断一个 key 是否包含在 map 中，因为 get 返回 null 有可能是不包含该 key，也有可能该 key 对应的 value 为 null。因为 HashMap 中允许 key 为 null，也允许 value 为 null。</li></ul><h3 id="hashmap-与-hashtable-的区别是什么" tabindex="-1"><a class="header-anchor" href="#hashmap-与-hashtable-的区别是什么" aria-hidden="true">#</a> HashMap 与 HashTable 的区别是什么？</h3><ul><li>HashMap 是 Hashtable 的轻量级实现，HashMap 允许 key 和 value 为 null，但最多允许一条记录的 key 为 null.而 HashTable 不允许。</li><li>HashTable 中的方法是线程安全的，而 HashMap 不是。在多线程访问 HashMap 需要提供额外的同步机制。</li><li>Hashtable 使用 Enumeration 进行遍历，HashMap 使用 Iterator 进行遍历</li></ul><h3 id="hashmap-与-concurrenthashmap-的区别是什么" tabindex="-1"><a class="header-anchor" href="#hashmap-与-concurrenthashmap-的区别是什么" aria-hidden="true">#</a> HashMap 与 ConcurrentHashMap 的区别是什么?</h3><ul><li>HashMap <ul><li>HashMap 是线程不安全的，当出现多线程操作时，会出现安全隐患；而 ConcurrentHashMap 是线程安全的。</li><li>HashMap 不支持并发操作，没有同步方法，ConcurrentHashMap 支持并发操作，通过继承 ReentrantLock（JDK1.7 重入锁）/CAS 和 synchronized(JDK1.8 内置锁) 来进行加锁（分段锁），每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</li></ul></li><li>ConcurrentHashMap <ul><li>ConcurrentHashMap 采用锁分段技术，将整个 Hash 桶进行了分段 segment，也就是将这个大的数组分成了几个小的片段 segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁。</li><li>ConcurrentHashMap 让锁的粒度更精细一些，并发性能更好。</li></ul></li></ul><h3 id="hashtable-和-concurrenthashmap-的区别" tabindex="-1"><a class="header-anchor" href="#hashtable-和-concurrenthashmap-的区别" aria-hidden="true">#</a> HashTable 和 ConcurrentHashMap 的区别？</h3><h3 id="concurrenthashmap-的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-的实现原理是什么" aria-hidden="true">#</a> ConcurrentHashMap 的实现原理是什么？</h3><ul><li>JDK7采用锁分段技术。</li><li>JDK8的改进 <ul><li>取消分段锁机制，采用CAS算法进行值的设置，如果CAS失败再使用 synchronized 加锁添加元素</li><li>引入红黑树结构，当某个槽内的元素个数超过8且 Node数组 容量大于 64 时，链表转为红黑树。</li><li>使用了更加优化的方式统计集合内的元素数量。</li></ul></li></ul><h3 id="hashset-的实现原理" tabindex="-1"><a class="header-anchor" href="#hashset-的实现原理" aria-hidden="true">#</a> HashSet 的实现原理？</h3><ul><li>HashSet 是基于 HashMap 实现的，底层采用 HashMap 来保存元素</li></ul><h3 id="hashset-怎么保证元素不重复的" tabindex="-1"><a class="header-anchor" href="#hashset-怎么保证元素不重复的" aria-hidden="true">#</a> HashSet 怎么保证元素不重复的？</h3><ul><li>元素的哈希值是通过元素的 hashcode 方法 来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</li></ul><h3 id="linkedhashmap-的实现原理" tabindex="-1"><a class="header-anchor" href="#linkedhashmap-的实现原理" aria-hidden="true">#</a> LinkedHashMap 的实现原理?</h3><ul><li>LinkedHashMap维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。</li></ul><h3 id="iterator-怎么使用-有什么特点" tabindex="-1"><a class="header-anchor" href="#iterator-怎么使用-有什么特点" aria-hidden="true">#</a> Iterator 怎么使用？有什么特点？</h3><ul><li>使用方法 iterator() 要求容器返回一个 Iterator。第一次调用 Iterator 的 next() 方法时，它返回序列的第一个元素。注意：iterator() 方法是 java.lang.Iterable 接口,被 Collection 继承。</li><li>使用 next() 获得序列中的下一个元素。</li><li>使用 hasNext() 检查序列中是否还有元素。</li><li>使用 remove() 将迭代器新返回的元素删除。</li><li>迭代器模式 (iterator pattern): 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示。</li></ul><h3 id="iterator-和-listiterator-有什么区别" tabindex="-1"><a class="header-anchor" href="#iterator-和-listiterator-有什么区别" aria-hidden="true">#</a> Iterator 和 ListIterator 有什么区别？</h3><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator即可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素、替换元素、获取前一个和后一个元素的索引等。</li></ul><h3 id="iterator-和-enumeration-接口的区别" tabindex="-1"><a class="header-anchor" href="#iterator-和-enumeration-接口的区别" aria-hidden="true">#</a> Iterator 和 Enumeration 接口的区别？</h3><ul><li>Iterator 除了能读取集合的数据之外，也能数据进行删除操作；而 Enumeration 只能读取集合的数据，而不能对数据进行修改。</li><li>Iterator 支持 fail-fast 机制，而 Enumeration 不支持 fail-fast 机制。Enumeration 是 JDK 1.0 添加的接口。 使用到它的函数包括 Vector、Hashtable 等类，这些类都是 JDK1.0 中加入的。Iterator 是 JDK1.2 添加的接口， Iterator 是基于 Enumeration 实现的，同时 Iterator 支持 fail-fast 机制，所以 Iterator 遍历集合时会比 Enumeration 遍历集合慢一些。</li></ul><h3 id="fail-fast-与-fail-safe-有什么区别" tabindex="-1"><a class="header-anchor" href="#fail-fast-与-fail-safe-有什么区别" aria-hidden="true">#</a> fail-fast 与 fail-safe 有什么区别？</h3><ul><li>fail-fast 直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出 ConcurrentModificationException 异常从而导致遍历失败。常见的使用 fail-fast 方式的容器有 HashMap 和 ArrayList 等。</li><li>fail-safe 这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用 fail-safe 方式遍历的容器有 ConcurrentHashMap 和 CopyOnWriteArrayList。</li></ul><h3 id="collection-和-collections-有什么区别" tabindex="-1"><a class="header-anchor" href="#collection-和-collections-有什么区别" aria-hidden="true">#</a> Collection 和 Collections 有什么区别？</h3><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法：Collections.sort(list);提供的反转方法：Collections.reverse(list)。</li></ul><h2 id="四、java并发-42-道" tabindex="-1"><a class="header-anchor" href="#四、java并发-42-道" aria-hidden="true">#</a> 四、Java并发 42 道</h2><h3 id="并行和并发有什么区别" tabindex="-1"><a class="header-anchor" href="#并行和并发有什么区别" aria-hidden="true">#</a> 并行和并发有什么区别？</h3><ul><li>并发是指一个处理器同时处理多个任务。</li><li>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</li></ul><h3 id="线程和进程的区别" tabindex="-1"><a class="header-anchor" href="#线程和进程的区别" aria-hidden="true">#</a> 线程和进程的区别？</h3><ul><li>进程是资源分配的最小单位</li><li>线程是CPU调度的最小单位</li><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li></ul><h3 id="守护线程是什么" tabindex="-1"><a class="header-anchor" href="#守护线程是什么" aria-hidden="true">#</a> 守护线程是什么？</h3><ul><li>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</li></ul><h3 id="创建线程的几种方式" tabindex="-1"><a class="header-anchor" href="#创建线程的几种方式" aria-hidden="true">#</a> 创建线程的几种方式？</h3><ul><li>继承Thread类，重写run()方法</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>
    <span class="token comment">//重写父类Thread的run()</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Demo</span> d1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Demo</span> d2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        d1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        d2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>实现Runnable接口，重写run()</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>

    <span class="token comment">//重写Runnable接口的run()</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>实现 Callable 接口</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在执行新建线程任务&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">&quot;结果&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Demo</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取任务执行后返回的结果</span>
        <span class="token class-name">String</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用线程池创建</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Executor</span> threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">//todo</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="runnable-和-callable-有什么区别" tabindex="-1"><a class="header-anchor" href="#runnable-和-callable-有什么区别" aria-hidden="true">#</a> Runnable 和 Callable 有什么区别？</h3><ul><li>与 Runnable 相比，Callable 可以有返回值</li></ul><h3 id="线程状态及转换" tabindex="-1"><a class="header-anchor" href="#线程状态及转换" aria-hidden="true">#</a> 线程状态及转换？</h3>`,46),X={href:"https://tobebetterjavaer.com/thread/thread-state-and-method.html#new",target:"_blank",rel:"noopener noreferrer"},Y={id:"sleep-和-wait-的区别",tabindex:"-1"},aa=a("a",{class:"header-anchor",href:"#sleep-和-wait-的区别","aria-hidden":"true"},"#",-1),ea={href:"https://www.pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html#threadsleep%E5%92%8Cobjectwait%E7%9A%84%E5%8C%BA%E5%88%AB",target:"_blank",rel:"noopener noreferrer"},na=a("ul",null,[a("li",null,"wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；"),a("li",null,"wait() 会释放锁，sleep() 不会。")],-1),sa=a("h3",{id:"线程的-run-和-start-有什么区别",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#线程的-run-和-start-有什么区别","aria-hidden":"true"},"#"),e(" 线程的 run() 和 start() 有什么区别？")],-1),ia=a("ul",null,[a("li",null,"当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。")],-1),ta={id:"在-java-程序中怎么保证多线程的运行安全",tabindex:"-1"},ra=a("a",{class:"header-anchor",href:"#在-java-程序中怎么保证多线程的运行安全","aria-hidden":"true"},"#",-1),ha={href:"https://www.pdai.tech/md/java/thread/java-thread-x-theorty.html#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},da=i('<h3 id="java-线程同步的几种方法" tabindex="-1"><a class="header-anchor" href="#java-线程同步的几种方法" aria-hidden="true">#</a> Java 线程同步的几种方法？</h3><ul><li>互斥同步</li><li>非阻塞同步</li></ul><h3 id="thread-interrupt-方法的工作原理是什么" tabindex="-1"><a class="header-anchor" href="#thread-interrupt-方法的工作原理是什么" aria-hidden="true">#</a> Thread.interrupt() 方法的工作原理是什么？</h3><ul><li>设置线程的中断状态为 true（默认是 flase）。</li></ul><h3 id="谈谈对-threadlocal-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对-threadlocal-的理解" aria-hidden="true">#</a> 谈谈对 ThreadLocal 的理解？</h3><ul><li>从ThreadLocal 这个类名可以顾名思义的进行理解，表示线程的“本地变量”，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的这样就可以避免共享资源的竞争。</li></ul><h3 id="在哪些场景下会使用到-threadlocal" tabindex="-1"><a class="header-anchor" href="#在哪些场景下会使用到-threadlocal" aria-hidden="true">#</a> 在哪些场景下会使用到 ThreadLocal？</h3><ul><li>threadLocal 只适用于共享对象会造成线程安全的业务场景。</li></ul><h3 id="说一说自己对于-synchronized-关键字的了解" tabindex="-1"><a class="header-anchor" href="#说一说自己对于-synchronized-关键字的了解" aria-hidden="true">#</a> 说一说自己对于 synchronized 关键字的了解？</h3><h3 id="如何在项目中使用-synchronized-的" tabindex="-1"><a class="header-anchor" href="#如何在项目中使用-synchronized-的" aria-hidden="true">#</a> 如何在项目中使用 synchronized 的？</h3><h3 id="说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" tabindex="-1"><a class="header-anchor" href="#说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" aria-hidden="true">#</a> 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h3><h3 id="谈谈-synchronized-和-reentrantlock-的区别" tabindex="-1"><a class="header-anchor" href="#谈谈-synchronized-和-reentrantlock-的区别" aria-hidden="true">#</a> 谈谈 synchronized 和 ReenTrantLock 的区别？</h3><h3 id="synchronized-和-volatile-的区别是什么" tabindex="-1"><a class="header-anchor" href="#synchronized-和-volatile-的区别是什么" aria-hidden="true">#</a> synchronized 和 volatile 的区别是什么？</h3><h3 id="谈一下你对-volatile-关键字的理解" tabindex="-1"><a class="header-anchor" href="#谈一下你对-volatile-关键字的理解" aria-hidden="true">#</a> 谈一下你对 volatile 关键字的理解？</h3><h3 id="说下对-reentrantreadwritelock-的理解" tabindex="-1"><a class="header-anchor" href="#说下对-reentrantreadwritelock-的理解" aria-hidden="true">#</a> 说下对 ReentrantReadWriteLock 的理解？</h3><h3 id="说下对悲观锁和乐观锁的理解" tabindex="-1"><a class="header-anchor" href="#说下对悲观锁和乐观锁的理解" aria-hidden="true">#</a> 说下对悲观锁和乐观锁的理解？</h3><h3 id="乐观锁常见的两种实现方式是什么" tabindex="-1"><a class="header-anchor" href="#乐观锁常见的两种实现方式是什么" aria-hidden="true">#</a> 乐观锁常见的两种实现方式是什么？</h3><h3 id="乐观锁的缺点有哪些" tabindex="-1"><a class="header-anchor" href="#乐观锁的缺点有哪些" aria-hidden="true">#</a> 乐观锁的缺点有哪些？</h3><h3 id="cas-和-synchronized-的使用场景" tabindex="-1"><a class="header-anchor" href="#cas-和-synchronized-的使用场景" aria-hidden="true">#</a> CAS 和 synchronized 的使用场景？</h3><h3 id="简单说下对-java-中的原子类的理解" tabindex="-1"><a class="header-anchor" href="#简单说下对-java-中的原子类的理解" aria-hidden="true">#</a> 简单说下对 Java 中的原子类的理解？</h3><h3 id="atomic-的原理是什么" tabindex="-1"><a class="header-anchor" href="#atomic-的原理是什么" aria-hidden="true">#</a> atomic 的原理是什么？</h3><h3 id="说下对同步器-aqs-的理解" tabindex="-1"><a class="header-anchor" href="#说下对同步器-aqs-的理解" aria-hidden="true">#</a> 说下对同步器 AQS 的理解？</h3><h3 id="aqs-的原理是什么" tabindex="-1"><a class="header-anchor" href="#aqs-的原理是什么" aria-hidden="true">#</a> AQS 的原理是什么？</h3><h3 id="aqs-对资源的共享模式有哪些" tabindex="-1"><a class="header-anchor" href="#aqs-对资源的共享模式有哪些" aria-hidden="true">#</a> AQS 对资源的共享模式有哪些？</h3><h3 id="aqs-底层使用了模板方法模式-你能说出几个需要重写的方法吗" tabindex="-1"><a class="header-anchor" href="#aqs-底层使用了模板方法模式-你能说出几个需要重写的方法吗" aria-hidden="true">#</a> AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗？</h3><h3 id="说下对信号量-semaphore-的理解" tabindex="-1"><a class="header-anchor" href="#说下对信号量-semaphore-的理解" aria-hidden="true">#</a> 说下对信号量 Semaphore 的理解？</h3><h3 id="countdownlatch-和-cyclicbarrier-有什么区别" tabindex="-1"><a class="header-anchor" href="#countdownlatch-和-cyclicbarrier-有什么区别" aria-hidden="true">#</a> CountDownLatch 和 CyclicBarrier 有什么区别？</h3><h3 id="说下对线程池的理解-为什么要使用线程池" tabindex="-1"><a class="header-anchor" href="#说下对线程池的理解-为什么要使用线程池" aria-hidden="true">#</a> 说下对线程池的理解？为什么要使用线程池？</h3><h3 id="创建线程池的参数有哪些" tabindex="-1"><a class="header-anchor" href="#创建线程池的参数有哪些" aria-hidden="true">#</a> 创建线程池的参数有哪些？</h3><h3 id="如何创建线程池" tabindex="-1"><a class="header-anchor" href="#如何创建线程池" aria-hidden="true">#</a> 如何创建线程池？</h3><h3 id="线程池中的的线程数一般怎么设置-需要考虑哪些问题" tabindex="-1"><a class="header-anchor" href="#线程池中的的线程数一般怎么设置-需要考虑哪些问题" aria-hidden="true">#</a> 线程池中的的线程数一般怎么设置？需要考虑哪些问题？</h3><h3 id="执行-execute-方法和-submit-方法的区别是什么呢" tabindex="-1"><a class="header-anchor" href="#执行-execute-方法和-submit-方法的区别是什么呢" aria-hidden="true">#</a> 执行 execute() 方法和 submit() 方法的区别是什么呢？</h3><h3 id="说下对-fork和join-并行计算框架的理解" tabindex="-1"><a class="header-anchor" href="#说下对-fork和join-并行计算框架的理解" aria-hidden="true">#</a> 说下对 Fork和Join 并行计算框架的理解？</h3><h3 id="jdk-中提供了哪些并发容器" tabindex="-1"><a class="header-anchor" href="#jdk-中提供了哪些并发容器" aria-hidden="true">#</a> JDK 中提供了哪些并发容器？</h3><h3 id="谈谈对-copyonwritearraylist-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对-copyonwritearraylist-的理解" aria-hidden="true">#</a> 谈谈对 CopyOnWriteArrayList 的理解？</h3><h3 id="谈谈对-blockingqueue-的理解-分别有哪些实现类" tabindex="-1"><a class="header-anchor" href="#谈谈对-blockingqueue-的理解-分别有哪些实现类" aria-hidden="true">#</a> 谈谈对 BlockingQueue 的理解？分别有哪些实现类？</h3><h3 id="谈谈对-concurrentskiplistmap-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对-concurrentskiplistmap-的理解" aria-hidden="true">#</a> 谈谈对 ConcurrentSkipListMap 的理解？</h3><h2 id="五、java-jvm-42-道" tabindex="-1"><a class="header-anchor" href="#五、java-jvm-42-道" aria-hidden="true">#</a> 五、Java JVM 42 道</h2><h3 id="说一下-jvm-的主要组成部分-及其作用" tabindex="-1"><a class="header-anchor" href="#说一下-jvm-的主要组成部分-及其作用" aria-hidden="true">#</a> 说一下 Jvm 的主要组成部分？及其作用？</h3><h3 id="谈谈对运行时数据区的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对运行时数据区的理解" aria-hidden="true">#</a> 谈谈对运行时数据区的理解？</h3><h3 id="堆和栈的区别是什么" tabindex="-1"><a class="header-anchor" href="#堆和栈的区别是什么" aria-hidden="true">#</a> 堆和栈的区别是什么？</h3><h3 id="堆中存什么-栈中存什么" tabindex="-1"><a class="header-anchor" href="#堆中存什么-栈中存什么" aria-hidden="true">#</a> 堆中存什么？栈中存什么？</h3><h3 id="为什么要把堆和栈区分出来呢-栈中不是也可以存储数据吗" tabindex="-1"><a class="header-anchor" href="#为什么要把堆和栈区分出来呢-栈中不是也可以存储数据吗" aria-hidden="true">#</a> 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</h3><h3 id="java-中的参数传递时传值呢-还是传引用-1" tabindex="-1"><a class="header-anchor" href="#java-中的参数传递时传值呢-还是传引用-1" aria-hidden="true">#</a> Java 中的参数传递时传值呢？还是传引用？</h3><h3 id="java-对象的大小是怎么计算的" tabindex="-1"><a class="header-anchor" href="#java-对象的大小是怎么计算的" aria-hidden="true">#</a> Java 对象的大小是怎么计算的？</h3><h3 id="对象的访问定位的两种方式" tabindex="-1"><a class="header-anchor" href="#对象的访问定位的两种方式" aria-hidden="true">#</a> 对象的访问定位的两种方式？</h3><h3 id="判断垃圾可以回收的方法有哪些" tabindex="-1"><a class="header-anchor" href="#判断垃圾可以回收的方法有哪些" aria-hidden="true">#</a> 判断垃圾可以回收的方法有哪些？</h3><h3 id="垃圾回收是从哪里开始的呢" tabindex="-1"><a class="header-anchor" href="#垃圾回收是从哪里开始的呢" aria-hidden="true">#</a> 垃圾回收是从哪里开始的呢？</h3><h3 id="被标记为垃圾的对象一定会被回收吗" tabindex="-1"><a class="header-anchor" href="#被标记为垃圾的对象一定会被回收吗" aria-hidden="true">#</a> 被标记为垃圾的对象一定会被回收吗？</h3><h3 id="谈谈对-java-中引用的了解" tabindex="-1"><a class="header-anchor" href="#谈谈对-java-中引用的了解" aria-hidden="true">#</a> 谈谈对 Java 中引用的了解？</h3><h3 id="谈谈对内存泄漏的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对内存泄漏的理解" aria-hidden="true">#</a> 谈谈对内存泄漏的理解？</h3><h3 id="内存泄露的根本原因是什么" tabindex="-1"><a class="header-anchor" href="#内存泄露的根本原因是什么" aria-hidden="true">#</a> 内存泄露的根本原因是什么？</h3><h3 id="举几个可能发生内存泄漏的情况" tabindex="-1"><a class="header-anchor" href="#举几个可能发生内存泄漏的情况" aria-hidden="true">#</a> 举几个可能发生内存泄漏的情况？</h3><h3 id="尽量避免内存泄漏的方法" tabindex="-1"><a class="header-anchor" href="#尽量避免内存泄漏的方法" aria-hidden="true">#</a> 尽量避免内存泄漏的方法？</h3><h3 id="常用的垃圾收集算法有哪些" tabindex="-1"><a class="header-anchor" href="#常用的垃圾收集算法有哪些" aria-hidden="true">#</a> 常用的垃圾收集算法有哪些？</h3><h3 id="为什么要采用分代收集算法" tabindex="-1"><a class="header-anchor" href="#为什么要采用分代收集算法" aria-hidden="true">#</a> 为什么要采用分代收集算法？</h3><h3 id="分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法" aria-hidden="true">#</a> 分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法？</h3><h3 id="什么是浮动垃圾" tabindex="-1"><a class="header-anchor" href="#什么是浮动垃圾" aria-hidden="true">#</a> 什么是浮动垃圾？</h3><h3 id="什么是内存碎片-如何解决" tabindex="-1"><a class="header-anchor" href="#什么是内存碎片-如何解决" aria-hidden="true">#</a> 什么是内存碎片？如何解决？</h3><h3 id="常用的垃圾收集器有哪些" tabindex="-1"><a class="header-anchor" href="#常用的垃圾收集器有哪些" aria-hidden="true">#</a> 常用的垃圾收集器有哪些？</h3><h3 id="谈谈你对-cms-垃圾收集器的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-cms-垃圾收集器的理解" aria-hidden="true">#</a> 谈谈你对 CMS 垃圾收集器的理解？</h3><h3 id="谈谈你对-g1-收集器的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-g1-收集器的理解" aria-hidden="true">#</a> 谈谈你对 G1 收集器的理解？</h3><h3 id="说下你对垃圾回收策略的理解-垃圾回收时机" tabindex="-1"><a class="header-anchor" href="#说下你对垃圾回收策略的理解-垃圾回收时机" aria-hidden="true">#</a> 说下你对垃圾回收策略的理解/垃圾回收时机？</h3><h3 id="谈谈你对内存分配的理解-大对象怎么分配-空间分配担保" tabindex="-1"><a class="header-anchor" href="#谈谈你对内存分配的理解-大对象怎么分配-空间分配担保" aria-hidden="true">#</a> 谈谈你对内存分配的理解？大对象怎么分配？空间分配担保？</h3><h3 id="说下你用过的-jvm-监控工具" tabindex="-1"><a class="header-anchor" href="#说下你用过的-jvm-监控工具" aria-hidden="true">#</a> 说下你用过的 JVM 监控工具？</h3><h3 id="如何利用监控工具调优" tabindex="-1"><a class="header-anchor" href="#如何利用监控工具调优" aria-hidden="true">#</a> 如何利用监控工具调优？</h3><h3 id="jvm-的一些参数" tabindex="-1"><a class="header-anchor" href="#jvm-的一些参数" aria-hidden="true">#</a> JVM 的一些参数？</h3><h3 id="谈谈你对类文件结构的理解-有哪些部分组成" tabindex="-1"><a class="header-anchor" href="#谈谈你对类文件结构的理解-有哪些部分组成" aria-hidden="true">#</a> 谈谈你对类文件结构的理解？有哪些部分组成？</h3><h3 id="谈谈你对类加载机制的了解" tabindex="-1"><a class="header-anchor" href="#谈谈你对类加载机制的了解" aria-hidden="true">#</a> 谈谈你对类加载机制的了解？</h3><h3 id="类加载各阶段的作用分别是什么" tabindex="-1"><a class="header-anchor" href="#类加载各阶段的作用分别是什么" aria-hidden="true">#</a> 类加载各阶段的作用分别是什么？</h3><h3 id="有哪些类加载器-分别有什么作用" tabindex="-1"><a class="header-anchor" href="#有哪些类加载器-分别有什么作用" aria-hidden="true">#</a> 有哪些类加载器？分别有什么作用？</h3><h3 id="类与类加载器的关系" tabindex="-1"><a class="header-anchor" href="#类与类加载器的关系" aria-hidden="true">#</a> 类与类加载器的关系?</h3><h3 id="谈谈你对双亲委派模型的理解-工作过程-为什么要使用" tabindex="-1"><a class="header-anchor" href="#谈谈你对双亲委派模型的理解-工作过程-为什么要使用" aria-hidden="true">#</a> 谈谈你对双亲委派模型的理解？工作过程？为什么要使用</h3><h3 id="怎么实现一个自定义的类加载器-需要注意什么" tabindex="-1"><a class="header-anchor" href="#怎么实现一个自定义的类加载器-需要注意什么" aria-hidden="true">#</a> 怎么实现一个自定义的类加载器？需要注意什么？</h3><h3 id="怎么打破双亲委派模型" tabindex="-1"><a class="header-anchor" href="#怎么打破双亲委派模型" aria-hidden="true">#</a> 怎么打破双亲委派模型？</h3><h3 id="有哪些实际场景是需要打破双亲委派模型的" tabindex="-1"><a class="header-anchor" href="#有哪些实际场景是需要打破双亲委派模型的" aria-hidden="true">#</a> 有哪些实际场景是需要打破双亲委派模型的？</h3><h3 id="谈谈你对编译期优化和运行期优化的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对编译期优化和运行期优化的理解" aria-hidden="true">#</a> 谈谈你对编译期优化和运行期优化的理解？</h3><h3 id="为何-hotspot-虚拟机要使用解释器与编译器并存的架构" tabindex="-1"><a class="header-anchor" href="#为何-hotspot-虚拟机要使用解释器与编译器并存的架构" aria-hidden="true">#</a> 为何 HotSpot 虚拟机要使用解释器与编译器并存的架构？</h3><h3 id="说下你对-java-内存模型的理解" tabindex="-1"><a class="header-anchor" href="#说下你对-java-内存模型的理解" aria-hidden="true">#</a> 说下你对 Java 内存模型的理解？</h3><h3 id="内存间的交互操作有哪些-需要满足什么规则" tabindex="-1"><a class="header-anchor" href="#内存间的交互操作有哪些-需要满足什么规则" aria-hidden="true">#</a> 内存间的交互操作有哪些？需要满足什么规则？</h3><h2 id="六、ssm框架-37-道" tabindex="-1"><a class="header-anchor" href="#六、ssm框架-37-道" aria-hidden="true">#</a> 六、SSM框架 37 道</h2><h3 id="使用-spring-框架的好处是什么" tabindex="-1"><a class="header-anchor" href="#使用-spring-框架的好处是什么" aria-hidden="true">#</a> 使用 Spring 框架的好处是什么？</h3><h3 id="解释下什么是-aop" tabindex="-1"><a class="header-anchor" href="#解释下什么是-aop" aria-hidden="true">#</a> 解释下什么是 AOP？</h3><h3 id="aop-的代理有哪几种方式" tabindex="-1"><a class="header-anchor" href="#aop-的代理有哪几种方式" aria-hidden="true">#</a> AOP 的代理有哪几种方式？</h3><h3 id="怎么实现-jdk-动态代理" tabindex="-1"><a class="header-anchor" href="#怎么实现-jdk-动态代理" aria-hidden="true">#</a> 怎么实现 JDK 动态代理？</h3><h3 id="aop-的基本概念-切面、连接点、切入点等" tabindex="-1"><a class="header-anchor" href="#aop-的基本概念-切面、连接点、切入点等" aria-hidden="true">#</a> AOP 的基本概念：切面、连接点、切入点等？</h3><h3 id="通知类型-advice-型-advice-有哪些" tabindex="-1"><a class="header-anchor" href="#通知类型-advice-型-advice-有哪些" aria-hidden="true">#</a> 通知类型（Advice）型（Advice）有哪些？</h3><h3 id="谈谈你对-ioc-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-ioc-的理解" aria-hidden="true">#</a> 谈谈你对 IOC 的理解？</h3><h3 id="bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#bean-的生命周期" aria-hidden="true">#</a> Bean 的生命周期？</h3><h3 id="bean-的作用域" tabindex="-1"><a class="header-anchor" href="#bean-的作用域" aria-hidden="true">#</a> Bean 的作用域?</h3><h3 id="spring-中的单例-bean-的线程安全问题了解吗" tabindex="-1"><a class="header-anchor" href="#spring-中的单例-bean-的线程安全问题了解吗" aria-hidden="true">#</a> Spring 中的单例 Bean 的线程安全问题了解吗？</h3><h3 id="谈谈你对-spring-中的事物的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-spring-中的事物的理解" aria-hidden="true">#</a> 谈谈你对 Spring 中的事物的理解？</h3><h3 id="spring-中的事务隔离级别" tabindex="-1"><a class="header-anchor" href="#spring-中的事务隔离级别" aria-hidden="true">#</a> Spring 中的事务隔离级别？</h3><h3 id="spring-中的事物传播行为" tabindex="-1"><a class="header-anchor" href="#spring-中的事物传播行为" aria-hidden="true">#</a> Spring 中的事物传播行为？</h3><h3 id="spring-常用的注入方式有哪些" tabindex="-1"><a class="header-anchor" href="#spring-常用的注入方式有哪些" aria-hidden="true">#</a> Spring 常用的注入方式有哪些？</h3><h3 id="spring-框架中用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#spring-框架中用到了哪些设计模式" aria-hidden="true">#</a> Spring 框架中用到了哪些设计模式？</h3><h3 id="applicationcontext-通常的实现有哪些" tabindex="-1"><a class="header-anchor" href="#applicationcontext-通常的实现有哪些" aria-hidden="true">#</a> ApplicationContext 通常的实现有哪些?</h3><h3 id="谈谈你对-mvc-模式的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-mvc-模式的理解" aria-hidden="true">#</a> 谈谈你对 MVC 模式的理解？</h3><h3 id="springmvc-的工作原理-执行流程" tabindex="-1"><a class="header-anchor" href="#springmvc-的工作原理-执行流程" aria-hidden="true">#</a> SpringMVC 的工作原理/执行流程？</h3><h3 id="springmvc-的核心组件有哪些" tabindex="-1"><a class="header-anchor" href="#springmvc-的核心组件有哪些" aria-hidden="true">#</a> SpringMVC 的核心组件有哪些？</h3><h3 id="springmvc-常用的注解有哪些" tabindex="-1"><a class="header-anchor" href="#springmvc-常用的注解有哪些" aria-hidden="true">#</a> SpringMVC 常用的注解有哪些？</h3><h3 id="requestmapping-的作用是什么" tabindex="-1"><a class="header-anchor" href="#requestmapping-的作用是什么" aria-hidden="true">#</a> @RequestMapping 的作用是什么？</h3><h3 id="如何解决-post-请求中文乱码问题-get-的又如何处理呢" tabindex="-1"><a class="header-anchor" href="#如何解决-post-请求中文乱码问题-get-的又如何处理呢" aria-hidden="true">#</a> 如何解决 POST 请求中文乱码问题，GET 的又如何处理呢？</h3><h3 id="springmvc-的控制器是不是单例模式-如果是会有什么问题-怎么解决" tabindex="-1"><a class="header-anchor" href="#springmvc-的控制器是不是单例模式-如果是会有什么问题-怎么解决" aria-hidden="true">#</a> SpringMVC 的控制器是不是单例模式，如果是会有什么问题，怎么解决？</h3><h3 id="springmvc-怎么样设定重定向和转发的" tabindex="-1"><a class="header-anchor" href="#springmvc-怎么样设定重定向和转发的" aria-hidden="true">#</a> SpringMVC 怎么样设定重定向和转发的？</h3><h3 id="springmvc-里面拦截器是怎么写的" tabindex="-1"><a class="header-anchor" href="#springmvc-里面拦截器是怎么写的" aria-hidden="true">#</a> SpringMVC 里面拦截器是怎么写的？</h3><h3 id="springmvc-和-struts2-的区别有哪些" tabindex="-1"><a class="header-anchor" href="#springmvc-和-struts2-的区别有哪些" aria-hidden="true">#</a> SpringMVC 和 Struts2 的区别有哪些?</h3><h3 id="谈谈你对-mybatis-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-mybatis-的理解" aria-hidden="true">#</a> 谈谈你对 MyBatis 的理解？</h3><h3 id="mybaits-的优缺点有哪些" tabindex="-1"><a class="header-anchor" href="#mybaits-的优缺点有哪些" aria-hidden="true">#</a> MyBaits 的优缺点有哪些？</h3><h3 id="mybatis-与-hibernate-有哪些不同" tabindex="-1"><a class="header-anchor" href="#mybatis-与-hibernate-有哪些不同" aria-hidden="true">#</a> MyBatis 与 Hibernate 有哪些不同？</h3><h3 id="mybatis-中-和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#mybatis-中-和-的区别是什么" aria-hidden="true">#</a> MyBatis 中 #{} 和 ${}的区别是什么？</h3><h3 id="mybatis-是如何进行分页的-分页插件的原理是什么" tabindex="-1"><a class="header-anchor" href="#mybatis-是如何进行分页的-分页插件的原理是什么" aria-hidden="true">#</a> MyBatis 是如何进行分页的？分页插件的原理是什么？</h3><h3 id="mybatis-有几种分页方式" tabindex="-1"><a class="header-anchor" href="#mybatis-有几种分页方式" aria-hidden="true">#</a> MyBatis 有几种分页方式？</h3><h3 id="mybatis-逻辑分页和物理分页的区别是什么" tabindex="-1"><a class="header-anchor" href="#mybatis-逻辑分页和物理分页的区别是什么" aria-hidden="true">#</a> MyBatis 逻辑分页和物理分页的区别是什么？</h3><h3 id="mybatis-是否支持延迟加载-如果支持-它的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#mybatis-是否支持延迟加载-如果支持-它的实现原理是什么" aria-hidden="true">#</a> MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><h3 id="说一下-mybatis-的一级缓存和二级缓存" tabindex="-1"><a class="header-anchor" href="#说一下-mybatis-的一级缓存和二级缓存" aria-hidden="true">#</a> 说一下 MyBatis 的一级缓存和二级缓存？</h3><h3 id="mybatis-有哪些执行器-executor" tabindex="-1"><a class="header-anchor" href="#mybatis-有哪些执行器-executor" aria-hidden="true">#</a> Mybatis 有哪些执行器（Executor）？</h3><h3 id="mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql的执行原理不" tabindex="-1"><a class="header-anchor" href="#mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql的执行原理不" aria-hidden="true">#</a> MyBatis 动态 SQL 是做什么的？都有哪些动态 SQL？能简述一下动态 SQL的执行原理不？</h3><h3 id="答案在我整理的一本《java面试八股文》pdf里都有-如果需要可以直接点击获取。" tabindex="-1"><a class="header-anchor" href="#答案在我整理的一本《java面试八股文》pdf里都有-如果需要可以直接点击获取。" aria-hidden="true">#</a> 答案在我整理的一本《Java面试八股文》PDF里都有，如果需要可以直接点击获取。</h3><h2 id="七、mysql-31-道" tabindex="-1"><a class="header-anchor" href="#七、mysql-31-道" aria-hidden="true">#</a> 七、MySQL 31 道</h2><h3 id="请说下你对-mysql-架构的了解" tabindex="-1"><a class="header-anchor" href="#请说下你对-mysql-架构的了解" aria-hidden="true">#</a> 请说下你对 MySQL 架构的了解？</h3><h3 id="一条-sql-语句在数据库框架中的执行流程" tabindex="-1"><a class="header-anchor" href="#一条-sql-语句在数据库框架中的执行流程" aria-hidden="true">#</a> 一条 SQL 语句在数据库框架中的执行流程？</h3><h3 id="数据库的三范式是什么" tabindex="-1"><a class="header-anchor" href="#数据库的三范式是什么" aria-hidden="true">#</a> 数据库的三范式是什么？</h3><h3 id="char-和-varchar-的区别" tabindex="-1"><a class="header-anchor" href="#char-和-varchar-的区别" aria-hidden="true">#</a> char 和 varchar 的区别？</h3><h3 id="varchar-10-和-varchar-20-的区别" tabindex="-1"><a class="header-anchor" href="#varchar-10-和-varchar-20-的区别" aria-hidden="true">#</a> varchar(10) 和 varchar(20) 的区别？</h3><h3 id="谈谈你对索引的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对索引的理解" aria-hidden="true">#</a> 谈谈你对索引的理解？</h3><h3 id="索引的底层使用的是什么数据结构" tabindex="-1"><a class="header-anchor" href="#索引的底层使用的是什么数据结构" aria-hidden="true">#</a> 索引的底层使用的是什么数据结构？</h3><h3 id="谈谈你对-b-树的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-b-树的理解" aria-hidden="true">#</a> 谈谈你对 B+ 树的理解？</h3><h3 id="为什么-innodb-存储引擎选用-b-树而不是-b-树呢" tabindex="-1"><a class="header-anchor" href="#为什么-innodb-存储引擎选用-b-树而不是-b-树呢" aria-hidden="true">#</a> 为什么 InnoDB 存储引擎选用 B+ 树而不是 B 树呢？</h3><h3 id="谈谈你对聚簇索引的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对聚簇索引的理解" aria-hidden="true">#</a> 谈谈你对聚簇索引的理解？</h3><h3 id="谈谈你对哈希索引的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对哈希索引的理解" aria-hidden="true">#</a> 谈谈你对哈希索引的理解？</h3><h3 id="谈谈你对覆盖索引的认识" tabindex="-1"><a class="header-anchor" href="#谈谈你对覆盖索引的认识" aria-hidden="true">#</a> 谈谈你对覆盖索引的认识？</h3><h3 id="索引的分类" tabindex="-1"><a class="header-anchor" href="#索引的分类" aria-hidden="true">#</a> 索引的分类？</h3><h3 id="谈谈你对最左前缀原则的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对最左前缀原则的理解" aria-hidden="true">#</a> 谈谈你对最左前缀原则的理解？</h3><h3 id="怎么知道创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因" tabindex="-1"><a class="header-anchor" href="#怎么知道创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因" aria-hidden="true">#</a> 怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?</h3><h3 id="什么情况下索引会失效-即查询不走索引" tabindex="-1"><a class="header-anchor" href="#什么情况下索引会失效-即查询不走索引" aria-hidden="true">#</a> 什么情况下索引会失效？即查询不走索引？</h3><h3 id="查询性能的优化方法" tabindex="-1"><a class="header-anchor" href="#查询性能的优化方法" aria-hidden="true">#</a> 查询性能的优化方法？</h3><h3 id="innodb-和-myisam-的比较" tabindex="-1"><a class="header-anchor" href="#innodb-和-myisam-的比较" aria-hidden="true">#</a> InnoDB 和 MyISAM 的比较？</h3><h3 id="谈谈你对水平切分和垂直切分的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对水平切分和垂直切分的理解" aria-hidden="true">#</a> 谈谈你对水平切分和垂直切分的理解？</h3><h3 id="主从复制中涉及到哪三个线程" tabindex="-1"><a class="header-anchor" href="#主从复制中涉及到哪三个线程" aria-hidden="true">#</a> 主从复制中涉及到哪三个线程？</h3><h3 id="主从同步的延迟原因及解决办法" tabindex="-1"><a class="header-anchor" href="#主从同步的延迟原因及解决办法" aria-hidden="true">#</a> 主从同步的延迟原因及解决办法？</h3><h3 id="谈谈你对数据库读写分离的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对数据库读写分离的理解" aria-hidden="true">#</a> 谈谈你对数据库读写分离的理解？</h3><h3 id="请你描述下事务的特性" tabindex="-1"><a class="header-anchor" href="#请你描述下事务的特性" aria-hidden="true">#</a> 请你描述下事务的特性？</h3><h3 id="谈谈你对事务隔离级别的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对事务隔离级别的理解" aria-hidden="true">#</a> 谈谈你对事务隔离级别的理解？</h3><h3 id="解释下什么叫脏读、不可重复读和幻读" tabindex="-1"><a class="header-anchor" href="#解释下什么叫脏读、不可重复读和幻读" aria-hidden="true">#</a> 解释下什么叫脏读、不可重复读和幻读？</h3><h3 id="mysql-默认的隔离级别是什么" tabindex="-1"><a class="header-anchor" href="#mysql-默认的隔离级别是什么" aria-hidden="true">#</a> MySQL 默认的隔离级别是什么？</h3><h3 id="谈谈你对mvcc-的了解" tabindex="-1"><a class="header-anchor" href="#谈谈你对mvcc-的了解" aria-hidden="true">#</a> 谈谈你对MVCC 的了解？</h3><h3 id="说一下-mysql-的行锁和表锁" tabindex="-1"><a class="header-anchor" href="#说一下-mysql-的行锁和表锁" aria-hidden="true">#</a> 说一下 MySQL 的行锁和表锁？</h3><h3 id="innodb-存储引擎的锁的算法有哪些" tabindex="-1"><a class="header-anchor" href="#innodb-存储引擎的锁的算法有哪些" aria-hidden="true">#</a> InnoDB 存储引擎的锁的算法有哪些？</h3><h3 id="mysql-问题排查都有哪些手段" tabindex="-1"><a class="header-anchor" href="#mysql-问题排查都有哪些手段" aria-hidden="true">#</a> MySQL 问题排查都有哪些手段？</h3><h3 id="mysql-数据库-cpu-飙升到-500-的话他怎么处理" tabindex="-1"><a class="header-anchor" href="#mysql-数据库-cpu-飙升到-500-的话他怎么处理" aria-hidden="true">#</a> MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？</h3><h2 id="八、redis-12-道" tabindex="-1"><a class="header-anchor" href="#八、redis-12-道" aria-hidden="true">#</a> 八、Redis 12 道</h2><h3 id="谈下你对-redis-的了解" tabindex="-1"><a class="header-anchor" href="#谈下你对-redis-的了解" aria-hidden="true">#</a> 谈下你对 Redis 的了解？</h3><h3 id="redis-一般都有哪些使用场景" tabindex="-1"><a class="header-anchor" href="#redis-一般都有哪些使用场景" aria-hidden="true">#</a> Redis 一般都有哪些使用场景？</h3><h3 id="redis-有哪些常见的功能" tabindex="-1"><a class="header-anchor" href="#redis-有哪些常见的功能" aria-hidden="true">#</a> Redis 有哪些常见的功能？</h3><h3 id="redis-支持的数据类型有哪些" tabindex="-1"><a class="header-anchor" href="#redis-支持的数据类型有哪些" aria-hidden="true">#</a> Redis 支持的数据类型有哪些？</h3><h3 id="redis-为什么这么快" tabindex="-1"><a class="header-anchor" href="#redis-为什么这么快" aria-hidden="true">#</a> Redis 为什么这么快？</h3><h3 id="什么是缓存穿透-怎么解决" tabindex="-1"><a class="header-anchor" href="#什么是缓存穿透-怎么解决" aria-hidden="true">#</a> 什么是缓存穿透？怎么解决？</h3><h3 id="什么是缓存雪崩-该如何解决" tabindex="-1"><a class="header-anchor" href="#什么是缓存雪崩-该如何解决" aria-hidden="true">#</a> 什么是缓存雪崩？该如何解决？</h3><h3 id="怎么保证缓存和数据库数据的一致性" tabindex="-1"><a class="header-anchor" href="#怎么保证缓存和数据库数据的一致性" aria-hidden="true">#</a> 怎么保证缓存和数据库数据的一致性？</h3><h3 id="redis-持久化有几种方式" tabindex="-1"><a class="header-anchor" href="#redis-持久化有几种方式" aria-hidden="true">#</a> Redis 持久化有几种方式？</h3><h3 id="redis-怎么实现分布式锁" tabindex="-1"><a class="header-anchor" href="#redis-怎么实现分布式锁" aria-hidden="true">#</a> Redis 怎么实现分布式锁？</h3><h3 id="redis-淘汰策略有哪些" tabindex="-1"><a class="header-anchor" href="#redis-淘汰策略有哪些" aria-hidden="true">#</a> Redis 淘汰策略有哪些？</h3><h3 id="redis-常见性能问题和解决方案" tabindex="-1"><a class="header-anchor" href="#redis-常见性能问题和解决方案" aria-hidden="true">#</a> Redis 常见性能问题和解决方案？</h3><h2 id="九、计算机网络-45-道" tabindex="-1"><a class="header-anchor" href="#九、计算机网络-45-道" aria-hidden="true">#</a> 九、计算机网络 45 道</h2><h3 id="为什么需要三次握手-两次不行" tabindex="-1"><a class="header-anchor" href="#为什么需要三次握手-两次不行" aria-hidden="true">#</a> 为什么需要三次握手？两次不行？</h3><h3 id="为什么需要四次挥手-三次不行" tabindex="-1"><a class="header-anchor" href="#为什么需要四次挥手-三次不行" aria-hidden="true">#</a> 为什么需要四次挥手？三次不行？</h3><h3 id="tcp与udp有哪些区别-各自应用场景" tabindex="-1"><a class="header-anchor" href="#tcp与udp有哪些区别-各自应用场景" aria-hidden="true">#</a> TCP与UDP有哪些区别？各自应用场景？</h3><h3 id="http1-0-1-1-2-0-的版本区别" tabindex="-1"><a class="header-anchor" href="#http1-0-1-1-2-0-的版本区别" aria-hidden="true">#</a> HTTP1.0，1.1，2.0 的版本区别</h3><h3 id="post和get有哪些区别-各自应用场景" tabindex="-1"><a class="header-anchor" href="#post和get有哪些区别-各自应用场景" aria-hidden="true">#</a> POST和GET有哪些区别？各自应用场景？</h3><h3 id="http-哪些常用的状态码及使用场景" tabindex="-1"><a class="header-anchor" href="#http-哪些常用的状态码及使用场景" aria-hidden="true">#</a> HTTP 哪些常用的状态码及使用场景？</h3><h3 id="http状态码301和302的区别-都有哪些用途" tabindex="-1"><a class="header-anchor" href="#http状态码301和302的区别-都有哪些用途" aria-hidden="true">#</a> HTTP状态码301和302的区别，都有哪些用途？</h3><h3 id="在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持" tabindex="-1"><a class="header-anchor" href="#在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持" aria-hidden="true">#</a> 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</h3><h3 id="http-如何实现长连接-在什么时候会超时" tabindex="-1"><a class="header-anchor" href="#http-如何实现长连接-在什么时候会超时" aria-hidden="true">#</a> HTTP 如何实现长连接？在什么时候会超时？</h3><h3 id="tcp-如何保证有效传输及拥塞控制原理" tabindex="-1"><a class="header-anchor" href="#tcp-如何保证有效传输及拥塞控制原理" aria-hidden="true">#</a> TCP 如何保证有效传输及拥塞控制原理</h3><h3 id="ip地址有哪些分类" tabindex="-1"><a class="header-anchor" href="#ip地址有哪些分类" aria-hidden="true">#</a> IP地址有哪些分类？</h3><h3 id="get请求中url编码的意义" tabindex="-1"><a class="header-anchor" href="#get请求中url编码的意义" aria-hidden="true">#</a> GET请求中URL编码的意义</h3><h3 id="什么是sql-注入-举个例子" tabindex="-1"><a class="header-anchor" href="#什么是sql-注入-举个例子" aria-hidden="true">#</a> 什么是SQL 注入？举个例子？</h3><h3 id="谈一谈-xss-攻击-举个例子" tabindex="-1"><a class="header-anchor" href="#谈一谈-xss-攻击-举个例子" aria-hidden="true">#</a> 谈一谈 XSS 攻击，举个例子？</h3><h3 id="讲一下网络五层模型-每一层的职责" tabindex="-1"><a class="header-anchor" href="#讲一下网络五层模型-每一层的职责" aria-hidden="true">#</a> 讲一下网络五层模型，每一层的职责？</h3><h3 id="简单说下-https-和-http-的区别" tabindex="-1"><a class="header-anchor" href="#简单说下-https-和-http-的区别" aria-hidden="true">#</a> 简单说下 HTTPS 和 HTTP 的区别</h3><h3 id="对称加密与非对称加密的区别" tabindex="-1"><a class="header-anchor" href="#对称加密与非对称加密的区别" aria-hidden="true">#</a> 对称加密与非对称加密的区别</h3><h3 id="简单说下每一层对应的网络协议有哪些" tabindex="-1"><a class="header-anchor" href="#简单说下每一层对应的网络协议有哪些" aria-hidden="true">#</a> 简单说下每一层对应的网络协议有哪些？</h3><h3 id="arp-协议的工作原理" tabindex="-1"><a class="header-anchor" href="#arp-协议的工作原理" aria-hidden="true">#</a> ARP 协议的工作原理？</h3><h3 id="tcp-的主要特点是什么" tabindex="-1"><a class="header-anchor" href="#tcp-的主要特点是什么" aria-hidden="true">#</a> TCP 的主要特点是什么？</h3><h3 id="udp-的主要特点是什么" tabindex="-1"><a class="header-anchor" href="#udp-的主要特点是什么" aria-hidden="true">#</a> UDP 的主要特点是什么？</h3><h3 id="tcp-和-udp-分别对应的常见应用层协议有哪些" tabindex="-1"><a class="header-anchor" href="#tcp-和-udp-分别对应的常见应用层协议有哪些" aria-hidden="true">#</a> TCP 和 UDP 分别对应的常见应用层协议有哪些？</h3><h3 id="为什么-time-wait-状态必须等待-2msl-的时间呢" tabindex="-1"><a class="header-anchor" href="#为什么-time-wait-状态必须等待-2msl-的时间呢" aria-hidden="true">#</a> 为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</h3><h3 id="保活计时器的作用" tabindex="-1"><a class="header-anchor" href="#保活计时器的作用" aria-hidden="true">#</a> 保活计时器的作用？</h3><h3 id="tcp-协议是如何保证可靠传输的" tabindex="-1"><a class="header-anchor" href="#tcp-协议是如何保证可靠传输的" aria-hidden="true">#</a> TCP 协议是如何保证可靠传输的？</h3><h3 id="谈谈你对停止等待协议的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对停止等待协议的理解" aria-hidden="true">#</a> 谈谈你对停止等待协议的理解？</h3><h3 id="谈谈你对-arq-协议的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对-arq-协议的理解" aria-hidden="true">#</a> 谈谈你对 ARQ 协议的理解？</h3><h3 id="谈谈你对滑动窗口的了解" tabindex="-1"><a class="header-anchor" href="#谈谈你对滑动窗口的了解" aria-hidden="true">#</a> 谈谈你对滑动窗口的了解？</h3><h3 id="谈下你对流量控制的理解" tabindex="-1"><a class="header-anchor" href="#谈下你对流量控制的理解" aria-hidden="true">#</a> 谈下你对流量控制的理解？</h3><h3 id="谈下你对-tcp-拥塞控制的理解-使用了哪些算法" tabindex="-1"><a class="header-anchor" href="#谈下你对-tcp-拥塞控制的理解-使用了哪些算法" aria-hidden="true">#</a> 谈下你对 TCP 拥塞控制的理解？使用了哪些算法？</h3><h3 id="什么是粘包" tabindex="-1"><a class="header-anchor" href="#什么是粘包" aria-hidden="true">#</a> 什么是粘包？</h3><h3 id="tcp-黏包是怎么产生的" tabindex="-1"><a class="header-anchor" href="#tcp-黏包是怎么产生的" aria-hidden="true">#</a> TCP 黏包是怎么产生的？</h3><h3 id="怎么解决拆包和粘包" tabindex="-1"><a class="header-anchor" href="#怎么解决拆包和粘包" aria-hidden="true">#</a> 怎么解决拆包和粘包？</h3><h3 id="forward-和-redirect-的区别" tabindex="-1"><a class="header-anchor" href="#forward-和-redirect-的区别" aria-hidden="true">#</a> forward 和 redirect 的区别？</h3><h3 id="http-方法有哪些" tabindex="-1"><a class="header-anchor" href="#http-方法有哪些" aria-hidden="true">#</a> HTTP 方法有哪些？</h3><h3 id="在浏览器中输入-url-地址到显示主页的过程" tabindex="-1"><a class="header-anchor" href="#在浏览器中输入-url-地址到显示主页的过程" aria-hidden="true">#</a> 在浏览器中输入 URL 地址到显示主页的过程？</h3><h3 id="dns-的解析过程" tabindex="-1"><a class="header-anchor" href="#dns-的解析过程" aria-hidden="true">#</a> DNS 的解析过程？</h3><h3 id="谈谈你对域名缓存的了解" tabindex="-1"><a class="header-anchor" href="#谈谈你对域名缓存的了解" aria-hidden="true">#</a> 谈谈你对域名缓存的了解？</h3><h3 id="谈下你对-http-长连接和短连接的理解-分别应用于哪些场景" tabindex="-1"><a class="header-anchor" href="#谈下你对-http-长连接和短连接的理解-分别应用于哪些场景" aria-hidden="true">#</a> 谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</h3><h3 id="https-的工作过程" tabindex="-1"><a class="header-anchor" href="#https-的工作过程" aria-hidden="true">#</a> HTTPS 的工作过程？</h3><h3 id="http-和-https-的区别" tabindex="-1"><a class="header-anchor" href="#http-和-https-的区别" aria-hidden="true">#</a> HTTP 和 HTTPS 的区别？</h3><h3 id="https-的优缺点" tabindex="-1"><a class="header-anchor" href="#https-的优缺点" aria-hidden="true">#</a> HTTPS 的优缺点？</h3><h3 id="什么是数字签名" tabindex="-1"><a class="header-anchor" href="#什么是数字签名" aria-hidden="true">#</a> 什么是数字签名？</h3><h3 id="什么是数字证书" tabindex="-1"><a class="header-anchor" href="#什么是数字证书" aria-hidden="true">#</a> 什么是数字证书？</h3><h3 id="cookie-和-session-有什么区别" tabindex="-1"><a class="header-anchor" href="#cookie-和-session-有什么区别" aria-hidden="true">#</a> Cookie 和 Session 有什么区别？</h3><h2 id="十、操作系统-32-道" tabindex="-1"><a class="header-anchor" href="#十、操作系统-32-道" aria-hidden="true">#</a> 十、操作系统 32 道</h2><h3 id="简单说下你对并发和并行的理解" tabindex="-1"><a class="header-anchor" href="#简单说下你对并发和并行的理解" aria-hidden="true">#</a> 简单说下你对并发和并行的理解？</h3><h3 id="同步、异步、阻塞、非阻塞的概念" tabindex="-1"><a class="header-anchor" href="#同步、异步、阻塞、非阻塞的概念" aria-hidden="true">#</a> 同步、异步、阻塞、非阻塞的概念</h3><h3 id="进程和线程的基本概念" tabindex="-1"><a class="header-anchor" href="#进程和线程的基本概念" aria-hidden="true">#</a> 进程和线程的基本概念</h3><h3 id="进程与线程的区别" tabindex="-1"><a class="header-anchor" href="#进程与线程的区别" aria-hidden="true">#</a> 进程与线程的区别？</h3><h3 id="为什么有了进程-还要有线程呢" tabindex="-1"><a class="header-anchor" href="#为什么有了进程-还要有线程呢" aria-hidden="true">#</a> 为什么有了进程，还要有线程呢？</h3><h3 id="进程的状态转换" tabindex="-1"><a class="header-anchor" href="#进程的状态转换" aria-hidden="true">#</a> 进程的状态转换</h3><h3 id="进程间的通信方式有哪些" tabindex="-1"><a class="header-anchor" href="#进程间的通信方式有哪些" aria-hidden="true">#</a> 进程间的通信方式有哪些？</h3><h3 id="进程的调度算法有哪些" tabindex="-1"><a class="header-anchor" href="#进程的调度算法有哪些" aria-hidden="true">#</a> 进程的调度算法有哪些？</h3><h3 id="什么是死锁" tabindex="-1"><a class="header-anchor" href="#什么是死锁" aria-hidden="true">#</a> 什么是死锁？</h3><h3 id="产生死锁的原因" tabindex="-1"><a class="header-anchor" href="#产生死锁的原因" aria-hidden="true">#</a> 产生死锁的原因？</h3><h3 id="死锁产生的必要条件" tabindex="-1"><a class="header-anchor" href="#死锁产生的必要条件" aria-hidden="true">#</a> 死锁产生的必要条件？</h3><h3 id="解决死锁的基本方法" tabindex="-1"><a class="header-anchor" href="#解决死锁的基本方法" aria-hidden="true">#</a> 解决死锁的基本方法？</h3><h3 id="怎么预防死锁" tabindex="-1"><a class="header-anchor" href="#怎么预防死锁" aria-hidden="true">#</a> 怎么预防死锁？</h3><h3 id="怎么避免死锁" tabindex="-1"><a class="header-anchor" href="#怎么避免死锁" aria-hidden="true">#</a> 怎么避免死锁？</h3><h3 id="怎么解除死锁" tabindex="-1"><a class="header-anchor" href="#怎么解除死锁" aria-hidden="true">#</a> 怎么解除死锁？</h3><h3 id="什么是缓冲区溢出-有什么危害" tabindex="-1"><a class="header-anchor" href="#什么是缓冲区溢出-有什么危害" aria-hidden="true">#</a> 什么是缓冲区溢出？有什么危害？</h3><h3 id="分页与分段的区别" tabindex="-1"><a class="header-anchor" href="#分页与分段的区别" aria-hidden="true">#</a> 分页与分段的区别？</h3><h3 id="物理地址、逻辑地址、虚拟内存的概念" tabindex="-1"><a class="header-anchor" href="#物理地址、逻辑地址、虚拟内存的概念" aria-hidden="true">#</a> 物理地址、逻辑地址、虚拟内存的概念</h3><h3 id="页面置换算法有哪些" tabindex="-1"><a class="header-anchor" href="#页面置换算法有哪些" aria-hidden="true">#</a> 页面置换算法有哪些？</h3><h3 id="谈谈你对动态链接库和静态链接库的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对动态链接库和静态链接库的理解" aria-hidden="true">#</a> 谈谈你对动态链接库和静态链接库的理解？</h3><h3 id="外中断和异常有什么区别" tabindex="-1"><a class="header-anchor" href="#外中断和异常有什么区别" aria-hidden="true">#</a> 外中断和异常有什么区别？</h3><h3 id="一个程序从开始运行到结束的完整过程-你能说出来多少" tabindex="-1"><a class="header-anchor" href="#一个程序从开始运行到结束的完整过程-你能说出来多少" aria-hidden="true">#</a> 一个程序从开始运行到结束的完整过程，你能说出来多少？</h3><h3 id="什么是用户态和内核态" tabindex="-1"><a class="header-anchor" href="#什么是用户态和内核态" aria-hidden="true">#</a> 什么是用户态和内核态</h3><h3 id="用户态和内核态是如何切换的" tabindex="-1"><a class="header-anchor" href="#用户态和内核态是如何切换的" aria-hidden="true">#</a> 用户态和内核态是如何切换的？</h3><h3 id="进程终止的方式" tabindex="-1"><a class="header-anchor" href="#进程终止的方式" aria-hidden="true">#</a> 进程终止的方式</h3><h3 id="守护进程、僵尸进程和孤儿进程" tabindex="-1"><a class="header-anchor" href="#守护进程、僵尸进程和孤儿进程" aria-hidden="true">#</a> 守护进程、僵尸进程和孤儿进程</h3><h3 id="如何避免僵尸进程" tabindex="-1"><a class="header-anchor" href="#如何避免僵尸进程" aria-hidden="true">#</a> 如何避免僵尸进程？</h3><h3 id="介绍一下几种典型的锁" tabindex="-1"><a class="header-anchor" href="#介绍一下几种典型的锁" aria-hidden="true">#</a> 介绍一下几种典型的锁？</h3><h3 id="常见内存分配内存错误" tabindex="-1"><a class="header-anchor" href="#常见内存分配内存错误" aria-hidden="true">#</a> 常见内存分配内存错误</h3><h3 id="内存交换中-被换出的进程保存在哪里" tabindex="-1"><a class="header-anchor" href="#内存交换中-被换出的进程保存在哪里" aria-hidden="true">#</a> 内存交换中，被换出的进程保存在哪里？</h3><h3 id="原子操作的是如何实现的" tabindex="-1"><a class="header-anchor" href="#原子操作的是如何实现的" aria-hidden="true">#</a> 原子操作的是如何实现的</h3><h3 id="抖动你知道是什么吗-它也叫颠簸现象" tabindex="-1"><a class="header-anchor" href="#抖动你知道是什么吗-它也叫颠簸现象" aria-hidden="true">#</a> 抖动你知道是什么吗？它也叫颠簸现象</h3><h2 id="十一、消息队列与分布式-26-道" tabindex="-1"><a class="header-anchor" href="#十一、消息队列与分布式-26-道" aria-hidden="true">#</a> 十一、消息队列与分布式 26 道</h2><h3 id="消息队列的基本作用" tabindex="-1"><a class="header-anchor" href="#消息队列的基本作用" aria-hidden="true">#</a> 消息队列的基本作用？</h3><h3 id="消息队列的优缺点有哪些" tabindex="-1"><a class="header-anchor" href="#消息队列的优缺点有哪些" aria-hidden="true">#</a> 消息队列的优缺点有哪些？</h3><h3 id="如何保证消息队列的高可用" tabindex="-1"><a class="header-anchor" href="#如何保证消息队列的高可用" aria-hidden="true">#</a> 如何保证消息队列的高可用？</h3><h3 id="如何保证消息不被重复消费-或者说-如何保证消息消费的幂等性" tabindex="-1"><a class="header-anchor" href="#如何保证消息不被重复消费-或者说-如何保证消息消费的幂等性" aria-hidden="true">#</a> 如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</h3><h3 id="如何保证消息的可靠性传输-或者说-如何处理消息丢失的问题" tabindex="-1"><a class="header-anchor" href="#如何保证消息的可靠性传输-或者说-如何处理消息丢失的问题" aria-hidden="true">#</a> 如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</h3><h3 id="如何保证消息的顺序性" tabindex="-1"><a class="header-anchor" href="#如何保证消息的顺序性" aria-hidden="true">#</a> 如何保证消息的顺序性？</h3><h3 id="大量消息在-mq-里长时间积压-该如何解决" tabindex="-1"><a class="header-anchor" href="#大量消息在-mq-里长时间积压-该如何解决" aria-hidden="true">#</a> 大量消息在 MQ 里长时间积压，该如何解决？</h3><h3 id="mq-中的消息过期失效了怎么办" tabindex="-1"><a class="header-anchor" href="#mq-中的消息过期失效了怎么办" aria-hidden="true">#</a> MQ 中的消息过期失效了怎么办？</h3><h3 id="rabbitmq-有哪些重要的角色" tabindex="-1"><a class="header-anchor" href="#rabbitmq-有哪些重要的角色" aria-hidden="true">#</a> RabbitMQ 有哪些重要的角色？</h3><h3 id="rabbitmq-有哪些重要的组件" tabindex="-1"><a class="header-anchor" href="#rabbitmq-有哪些重要的组件" aria-hidden="true">#</a> RabbitMQ 有哪些重要的组件？</h3><h3 id="rabbitmq-有几种广播类型" tabindex="-1"><a class="header-anchor" href="#rabbitmq-有几种广播类型" aria-hidden="true">#</a> RabbitMQ 有几种广播类型？</h3><h3 id="kafka-可以脱离-zookeeper-单独使用吗-为什么" tabindex="-1"><a class="header-anchor" href="#kafka-可以脱离-zookeeper-单独使用吗-为什么" aria-hidden="true">#</a> Kafka 可以脱离 zookeeper 单独使用吗？为什么？</h3><h3 id="kafka-有几种数据保留的策略" tabindex="-1"><a class="header-anchor" href="#kafka-有几种数据保留的策略" aria-hidden="true">#</a> Kafka 有几种数据保留的策略？</h3><h3 id="kafka-的分区策略有哪些" tabindex="-1"><a class="header-anchor" href="#kafka-的分区策略有哪些" aria-hidden="true">#</a> Kafka 的分区策略有哪些？</h3><h3 id="谈下你对-zookeeper-的认识" tabindex="-1"><a class="header-anchor" href="#谈下你对-zookeeper-的认识" aria-hidden="true">#</a> 谈下你对 Zookeeper 的认识？</h3><h3 id="zookeeper-都有哪些功能" tabindex="-1"><a class="header-anchor" href="#zookeeper-都有哪些功能" aria-hidden="true">#</a> Zookeeper 都有哪些功能？</h3><h3 id="谈下你对-zab-协议的了解" tabindex="-1"><a class="header-anchor" href="#谈下你对-zab-协议的了解" aria-hidden="true">#</a> 谈下你对 ZAB 协议的了解？</h3><h3 id="zookeeper-怎么保证主从节点的状态同步" tabindex="-1"><a class="header-anchor" href="#zookeeper-怎么保证主从节点的状态同步" aria-hidden="true">#</a> Zookeeper 怎么保证主从节点的状态同步？</h3><h3 id="zookeeper-有几种部署模式" tabindex="-1"><a class="header-anchor" href="#zookeeper-有几种部署模式" aria-hidden="true">#</a> Zookeeper 有几种部署模式？</h3><h3 id="说一下-zookeeper-的通知机制" tabindex="-1"><a class="header-anchor" href="#说一下-zookeeper-的通知机制" aria-hidden="true">#</a> 说一下 Zookeeper 的通知机制？</h3><h3 id="集群中为什么要有主节点" tabindex="-1"><a class="header-anchor" href="#集群中为什么要有主节点" aria-hidden="true">#</a> 集群中为什么要有主节点？</h3><h3 id="集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗" tabindex="-1"><a class="header-anchor" href="#集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗" aria-hidden="true">#</a> 集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？</h3><h3 id="说一下两阶段提交和三阶段提交的过程-分别有什么问题" tabindex="-1"><a class="header-anchor" href="#说一下两阶段提交和三阶段提交的过程-分别有什么问题" aria-hidden="true">#</a> 说一下两阶段提交和三阶段提交的过程？分别有什么问题？</h3><h3 id="zookeeper-宕机如何处理" tabindex="-1"><a class="header-anchor" href="#zookeeper-宕机如何处理" aria-hidden="true">#</a> Zookeeper 宕机如何处理？</h3><h3 id="说下四种类型的数据节点-znode" tabindex="-1"><a class="header-anchor" href="#说下四种类型的数据节点-znode" aria-hidden="true">#</a> 说下四种类型的数据节点 Znode？</h3><h3 id="zookeeper-和-dubbo-的关系" tabindex="-1"><a class="header-anchor" href="#zookeeper-和-dubbo-的关系" aria-hidden="true">#</a> Zookeeper 和 Dubbo 的关系？</h3>',270);function la(ca,oa){const n=d("ExternalLinkIcon");return r(),h("div",null,[m,x,a("h3",v,[y,e(),a("a",g,[e("解释下什么是面向对象？面向对象和面向过程的区别？"),s(n)])]),w,a("h3",S,[_,e(),a("a",j,[e("面向对象的三大特性？分别解释下？"),s(n)])]),q,a("h3",M,[C,e(),a("a",J,[e("两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？"),s(n)])]),H,a("ul",null,[a("li",null,[e("Java 的参数是以值传递的形式传入方法中，而不是引用传递。 "),a("a",E,[e("StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?"),s(n)])])]),I,a("h3",L,[T,e(),a("a",A,[e("String 为什么要设计为不可变类？"),s(n)])]),z,a("ul",null,[a("li",null,[e("BIO 就是传统的 "),a("a",B,[e("java.io"),s(n)]),e(" 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前， 线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。")]),O,D]),P,a("ul",null,[a("li",null,[a("a",R,[e("Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。"),s(n)])]),a("li",null,[a("a",K,[e("程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。"),s(n)])])]),V,a("h3",Q,[F,e(),a("a",N,[e("HashMap 的 put 方法的执行过程？"),s(n)])]),U,a("h3",Z,[G,e(),a("a",W,[e("HashMap 的 size 为什么必须是 2 的整数次方？"),s(n)])]),$,a("ul",null,[a("li",null,[a("a",X,[e("Java 线程的6种状态及切换(透彻讲解)"),s(n)])])]),a("h3",Y,[aa,e(),a("a",ea,[e("sleep() 和 wait() 的区别？"),s(n)])]),na,sa,ia,a("h3",ta,[ra,e(),a("a",ha,[e("在 Java 程序中怎么保证多线程的运行安全？"),s(n)])]),da])}const pa=t(f,[["render",la],["__file","eight-legged-essay-java.html.vue"]]);export{pa as default};
