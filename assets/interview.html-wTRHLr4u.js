import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o as d,c as s,b as e,d as i,e as a,f as r}from"./app-9HIzqMwZ.js";const h={},o=r('<h1 id="个人经验总结" tabindex="-1"><a class="header-anchor" href="#个人经验总结" aria-hidden="true">#</a> 个人经验总结</h1><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> <em>基础</em></h2><h3 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-6.png" alt=""></p><h3 id="强转" tabindex="-1"><a class="header-anchor" href="#强转" aria-hidden="true">#</a> 强转</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-7.png" alt=""></p><h3 id="访问修饰符" tabindex="-1"><a class="header-anchor" href="#访问修饰符" aria-hidden="true">#</a> 访问修饰符</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-12.png" alt=""></p><h3 id="final-关键字" tabindex="-1"><a class="header-anchor" href="#final-关键字" aria-hidden="true">#</a> final 关键字</h3><ul><li>被 final 修饰的类不可以被继承 <ul><li>String 类被 final 关键字修饰</li></ul></li><li>被 final 修饰的方法不可以被重写</li><li>被 final 修饰的变量不可变，被 final 修饰的变量必须被显式第指定初始值，还得注意的是，这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变。</li></ul><h3 id="integer小知识" tabindex="-1"><a class="header-anchor" href="#integer小知识" aria-hidden="true">#</a> Integer小知识:</h3>',11),c={href:"https://mp.weixin.qq.com/s/mBs5k2LnoGMerpE2vAQzyg",target:"_blank",rel:"noopener noreferrer"},u=e("mark",null,"1000为false而100",-1),E=r(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Integer a = 1000, b = 1000;  
System.out.println(a == b);
Integer c = 100, d = 100;  
System.out.println(c == d);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>false
true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,2),_=e("h3",{id:"nio-和-io-区别",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#nio-和-io-区别","aria-hidden":"true"},"#"),i(" NIO 和 IO 区别")],-1),p=e("ul",null,[e("li",null,"NIO 是非阻塞的"),e("li",null,"NIO 面向块，I/O 面向流")],-1),m=e("h2",{id:"spring",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#spring","aria-hidden":"true"},"#"),i(),e("em",null,"Spring")],-1),b={id:"spring-boot-生命周期",tabindex:"-1"},f=e("a",{class:"header-anchor",href:"#spring-boot-生命周期","aria-hidden":"true"},"#",-1),g={href:"https://blog.csdn.net/f641385712/article/details/105762050",target:"_blank",rel:"noopener noreferrer"},B=r(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ApplicationStartingEvent：开始启动中
ApplicationEnvironmentPreparedEvent：环境已准备好
ApplicationContextInitializedEvent：上下文已实例化
ApplicationPreparedEvent：上下文已准备好
ApplicationStartedEvent：应用成功启动
ApplicationReadyEvent：应用已准备好
ApplicationFailedEvent：应用启动失败
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="获取上下文方式" tabindex="-1"><a class="header-anchor" href="#获取上下文方式" aria-hidden="true">#</a> 获取上下文方式：</h3>`,2),A={href:"https://hutool.cn/docs/#/extra/Spring/Spring%E5%B7%A5%E5%85%B7-SpringUtil",target:"_blank",rel:"noopener noreferrer"},v={href:"https://github.com/yuanmabiji/Java-SourceCode-Blogs/blob/master/SpringBoot/10%20SpringBoot%E5%86%85%E7%BD%AE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%20%20SpringBoot%E6%BA%90%E7%A0%81(%E5%8D%81).md",target:"_blank",rel:"noopener noreferrer"},x={href:"https://docsify.tobebetterjavaer.com/#/docs/sidebar/sanfene/spring",target:"_blank",rel:"noopener noreferrer"},w=e("h2",{id:"mysql",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mysql","aria-hidden":"true"},"#"),i(),e("em",null,"Mysql")],-1),k={id:"存储引擎",tabindex:"-1"},S=e("a",{class:"header-anchor",href:"#存储引擎","aria-hidden":"true"},"#",-1),T={href:"https://www.pdai.tech/md/db/sql-mysql/sql-mysql-engine.html#mysql---%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E",target:"_blank",rel:"noopener noreferrer"},R=r("<ul><li>InnoDB <ul><li>事务型存储引擎</li><li>四个标准隔离级别</li><li>主索引是聚簇索引</li><li>支持真正的在线热备份</li><li>支持表跟行级锁</li><li>支持外键</li></ul></li><li>MyISAM <ul><li>不支持事务</li><li>不支持行级锁</li><li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</li><li>其它特性: MyISAM 支持压缩表和空间数据索引</li></ul></li></ul>",1),F={id:"sql-优化",tabindex:"-1"},C=e("a",{class:"header-anchor",href:"#sql-优化","aria-hidden":"true"},"#",-1),I={href:"https://www.pdai.tech/md/db/sql-lan/sql-lan-optimize.html#sql%E8%AF%AD%E8%A8%80---sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96",target:"_blank",rel:"noopener noreferrer"},D=e("h2",{id:"redis",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#redis","aria-hidden":"true"},"#"),i(),e("em",null,"Redis")],-1),O=e("h3",{id:"分布式锁",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#分布式锁","aria-hidden":"true"},"#"),i(" 分布式锁")],-1),P=e("li",null,[i('这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，'),e("br"),i(" 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。")],-1),M=e("li",null,[i("实现 "),e("ul",null,[e("li",null,"单个Redis实例：setnx(key,当前时间+过期时间) + Lua"),e("li",null,"Redis集群模式：Redlock")])],-1),y=e("li",null,"借助 Redis 实现分布式锁时，有一个共同的缺陷: 当获取锁被拒绝后，需要不断的循环，重新发送获取锁(创建 key )的请求，直到请求成功。这就造成空转，浪费宝贵的 CPU 资源。",-1),z={href:"https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html",target:"_blank",rel:"noopener noreferrer"},N={href:"http://antirez.com/news/101",target:"_blank",rel:"noopener noreferrer"},q=r(`<h3 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h3><ul><li>缓存穿透 <ul><li>缓存穿透是指缓存和数据库中都没有的数据</li><li>解决： <ul><li>接口层增加校验</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null</li><li>布隆过滤器</li></ul></li></ul></li><li>缓存击穿 <ul><li>缓存击穿是指缓存中没有但数据库中有的数据(一般是缓存时间到期)</li><li>解决： <ul><li>设置热点数据永远不过期</li><li>接口限流与熔断，降级</li><li>加互斥锁</li></ul></li></ul></li><li>缓存雪崩 <ul><li>缓存雪崩是指缓存中数据大批量到过期时间</li><li>解决： <ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中</li><li>设置热点数据永远不过期</li></ul></li></ul></li><li>用途</li></ul><h2 id="mq" tabindex="-1"><a class="header-anchor" href="#mq" aria-hidden="true">#</a> <em>MQ</em></h2><h3 id="集群高可用部署" tabindex="-1"><a class="header-anchor" href="#集群高可用部署" aria-hidden="true">#</a> 集群高可用部署</h3><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> <em>事务</em></h2><h3 id="分布事务" tabindex="-1"><a class="header-anchor" href="#分布事务" aria-hidden="true">#</a> 分布事务</h3><ul><li>Seata <ul><li>TC (Transaction Coordinator) - 事务协调者 <ul><li>维护全局和分支事务的状态，指示全局提交或者回滚。</li></ul></li><li>TM (Transaction Manager) - 事务管理器 <ul><li>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li></ul></li><li>RM (Resource Manager) - 资源管理器 <ul><li>管理执行分支事务的那些资源，向 TC 注册分支事务、上报分支事务状态、控制分支事务的提交或者回滚。</li></ul></li><li>TM是一个分布式事务的发起者和终结者(管理者)，TC 负责维护分布式事务的运行状态，而 RM 则负责本地事务的运行。三个组件相互协作，其中 TC 以 Server 形式独立部署，TM 和 RM 集成在应用中启动</li></ul></li></ul><h3 id="spring事务" tabindex="-1"><a class="header-anchor" href="#spring事务" aria-hidden="true">#</a> Spring事务</h3><ul><li>传播机制<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>PROPAGATION_REQUIRED —— 支持当前事务，如果当前没有事务，则新建一个事务，这是最常见的选择，也是 Spring 默认的一个事务传播属性。
PROPAGATION_SUPPORTS —— 支持当前事务，如果当前没有事务，则以非事务方式执行。
PROPAGATION_MANDATORY —— 支持当前事务，如果当前没有事务，则抛出异常。
PROPAGATION_REQUIRES_NEW —— 新建事务，如果当前存在事务，把当前事务挂起。
PROPAGATION_NOT_SUPPORTED —— 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER —— 以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED —— Nested 的事务和它的父事务是相依的，它的提交是要等和它的父事务一块提交的。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>四大特性：原子性、一致性、隔离性、持久性</li><li>隔离级别：<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
未提交读 (read uncommited) :脏读，不可重复读，虚读都有可能发生
已提交读 (read commited):避免脏读。但是不可重复读和虚读有可能发生
可重复读 (repeatable read) :避免脏读和不可重复读.但是虚读有可能发生.
串行化的 (serializable) :避免以上所有读问题.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>可能引起失效原因： <ul><li>@Transactional 应用在非 public 修饰的方法上</li><li>@Transactional 注解属性 propagation(传播机制) 设置错误</li><li>@Transactional 注解属性 rollbackFor 设置错误</li><li>同一个类中方法调用，导致@Transactional 失效</li></ul></li></ul><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> <em>设计模式</em></h2><h3 id="spring中应用的设计模式" tabindex="-1"><a class="header-anchor" href="#spring中应用的设计模式" aria-hidden="true">#</a> Spring中应用的设计模式</h3><ul><li>工厂模式 <ul><li>Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li></ul></li><li>代理模式 <ul><li>Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</li></ul></li><li>单例模式 <ul><li>Spring 中的 Bean 默认都是单例的，这样有利于容器对 Bean 的管理。</li></ul></li><li>模板模式 <ul><li>Spring 中 JdbcTemplate、RestTemplate 等以 Template 结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。</li></ul></li><li>观察者模式 <ul><li>Spring 事件驱动模型就是观察者模式很经典的一个应用。</li></ul></li><li>适配器模式 <ul><li>Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</li></ul></li><li>策略模式 <ul><li>Spring 中有一个 Resource 接口，它的不同实现类，会根据不同的策略去访问资源。</li></ul></li></ul><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程" aria-hidden="true">#</a> <em>多线程</em></h2><h3 id="线程使用方式" tabindex="-1"><a class="header-anchor" href="#线程使用方式" aria-hidden="true">#</a> 线程使用方式</h3><ul><li>实现 Runnable 接口 <ul><li>需要实现 run() 方法。</li><li>通过 Thread 调用 start() 方法来启动线程。</li></ul></li><li>实现 Callable 接口 <ul><li>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</li></ul></li><li>继承 Thread 类 <ul><li>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</li><li>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</li></ul></li></ul>`,15),j={id:"threadlocal",tabindex:"-1"},L=e("a",{class:"header-anchor",href:"#threadlocal","aria-hidden":"true"},"#",-1),U={href:"https://www.pdai.tech/md/java/thread/java-thread-x-threadlocal.html#java-%E5%B9%B6%E5%8F%91---threadlocal%E8%AF%A6%E8%A7%A3",target:"_blank",rel:"noopener noreferrer"},G=e("ul",null,[e("li",null,"ThreadLocal是通过线程隔离的方式防止任务在共享资源上产生冲突, 线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储")],-1),V=e("h2",{id:"分布式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#分布式","aria-hidden":"true"},"#"),i(),e("em",null,"分布式")],-1),Q=e("h3",{id:"跨服务之间分页查询实现及大量数据导出情况",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#跨服务之间分页查询实现及大量数据导出情况","aria-hidden":"true"},"#"),i(" 跨服务之间分页查询实现及大量数据导出情况")],-1),J=e("ul",null,[e("li",null,"个人实际经历是针对当前服务为主体进行查询，遍历获取对应的 id，然后 RPC 调用其它服务通过 id 去获取数据集合，再对其进行封装。"),e("li",null,"针对导出需要查询大量数据的情况，则是采取服务端生成形式。")],-1),H={id:"分库分表实现",tabindex:"-1"},W=e("a",{class:"header-anchor",href:"#分库分表实现","aria-hidden":"true"},"#",-1),Y={href:"https://www.pdai.tech/md/framework/ds-sharding/sharding-x-arch.html",target:"_blank",rel:"noopener noreferrer"},K={id:"分布式锁实现",tabindex:"-1"},X=e("a",{class:"header-anchor",href:"#分布式锁实现","aria-hidden":"true"},"#",-1),Z={href:"https://www.pdai.tech/md/arch/arch-z-lock.html#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F---%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88",target:"_blank",rel:"noopener noreferrer"},$={href:"https://www.pdai.tech/md/arch/arch-z-lock.html#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7",target:"_blank",rel:"noopener noreferrer"},ee={href:"https://www.pdai.tech/md/arch/arch-z-lock.html#%E5%9F%BA%E4%BA%8Eredis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7",target:"_blank",rel:"noopener noreferrer"},ie=e("ul",null,[e("li",null,"参照上面Redis知识整理")],-1),le={href:"https://www.pdai.tech/md/arch/arch-z-lock.html#%E5%9F%BA%E4%BA%8Ezookeeper%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81",target:"_blank",rel:"noopener noreferrer"},ae={id:"分布式-id-实现",tabindex:"-1"},re=e("a",{class:"header-anchor",href:"#分布式-id-实现","aria-hidden":"true"},"#",-1),ne={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id",target:"_blank",rel:"noopener noreferrer"},te={href:"https://www.pdai.tech/md/arch/arch-z-id.html#uuid",target:"_blank",rel:"noopener noreferrer"},de={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90",target:"_blank",rel:"noopener noreferrer"},se={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E4%BD%BF%E7%94%A8redis%E5%AE%9E%E7%8E%B0",target:"_blank",rel:"noopener noreferrer"},he={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95-snowflake",target:"_blank",rel:"noopener noreferrer"},oe={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E7%99%BE%E5%BA%A6-uidgenerator",target:"_blank",rel:"noopener noreferrer"},ce={href:"https://www.pdai.tech/md/arch/arch-z-id.html#%E7%BE%8E%E5%9B%A2leaf",target:"_blank",rel:"noopener noreferrer"},ue={href:"https://www.pdai.tech/md/arch/arch-z-id.html#mist-%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},Ee={id:"微服务组件",tabindex:"-1"},_e=e("a",{class:"header-anchor",href:"#微服务组件","aria-hidden":"true"},"#",-1),pe={href:"https://www.pdai.tech/md/interview/x-interview-2.html#141-spring-cloud",target:"_blank",rel:"noopener noreferrer"},me={href:"https://www.pdai.tech/md/arch/arch-z-overview.html",target:"_blank",rel:"noopener noreferrer"},be=e("h2",{id:"高并发",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#高并发","aria-hidden":"true"},"#"),i(),e("em",null,"高并发")],-1),fe={id:"接口幂等性",tabindex:"-1"},ge=e("a",{class:"header-anchor",href:"#接口幂等性","aria-hidden":"true"},"#",-1),Be={href:"https://www.pdai.tech/md/spring/springboot/springboot-x-interface-mideng.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89",target:"_blank",rel:"noopener noreferrer"},Ae=r('<ul><li>从幂等和防止重复提交，接口幂等和常见的保证幂等的方式等知识点构筑知识体系 <ul><li>幂等: 更多的是在重复请求已经发生，或是无法避免的情况下，采取一定的技术手段让这些重复请求不给系统带来副作用</li><li>防止重复提交: 更多的是不让用户发起多次一样的请求,主要还是从客户端的角度来解决这个问题</li></ul></li><li>保证幂等方式 <ul><li>数据库层面 <ul><li>悲观锁: for update</li></ul></li><li>唯一 ID/索引</li><li>乐观锁 <ul><li>使用版本号或者时间戳</li><li>状态机</li></ul></li></ul></li><li>分布式锁</li></ul><h2 id="其它" tabindex="-1"><a class="header-anchor" href="#其它" aria-hidden="true">#</a> <em>其它</em></h2>',2),ve={id:"秒杀系统",tabindex:"-1"},xe=e("a",{class:"header-anchor",href:"#秒杀系统","aria-hidden":"true"},"#",-1),we={href:"https://www.pdai.tech/md/arch/arch-example-seckill.html#%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B---%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1",target:"_blank",rel:"noopener noreferrer"},ke=e("ul",null,[e("li",null,"遇到的印象最深的问题，如何解决"),e("li",null,"常用中间件实现原理")],-1),Se={id:"前后端分离接口安全",tabindex:"-1"},Te=e("a",{class:"header-anchor",href:"#前后端分离接口安全","aria-hidden":"true"},"#",-1),Re={href:"https://www.pdai.tech/md/spring/springboot/springboot-x-interface-jiami.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"};function Fe(Ce,Ie){const l=t("ExternalLinkIcon");return d(),s("div",null,[o,e("ul",null,[e("li",null,[e("p",null,[e("a",c,[i("涉及IntegerCache，1000"),u,i("100为true"),a(l)]),i(":")]),E])]),_,p,m,e("h3",b,[f,i(),e("a",g,[i("Spring boot 生命周期"),a(l)])]),B,e("ul",null,[e("li",null,[e("a",A,[i("实现ApplicationContextAware"),a(l)])])]),e("p",null,[e("a",v,[i("SpringBoot内置生命周期事件详解"),a(l)])]),e("p",null,[e("a",x,[i("Spring：35道精选面试题"),a(l)])]),w,e("h3",k,[S,i(),e("a",T,[i("存储引擎"),a(l)])]),R,e("h3",F,[C,i(),e("a",I,[i("SQL 优化"),a(l)])]),D,O,e("ul",null,[P,M,e("li",null,[i("缺点 "),e("ul",null,[y,e("li",null,[i("RedLock算法本身有争议，具体看这篇文章 "),e("a",z,[i("How to do distributed locking"),a(l)]),i(" (opens new window) 以及作者的回复 "),e("a",N,[i("Is Redlock safe?"),a(l)])])])])]),q,e("h3",j,[L,i(),e("a",U,[i("ThreadLocal"),a(l)])]),G,V,Q,J,e("h3",H,[W,i(),e("a",Y,[i("分库分表实现"),a(l)])]),e("h3",K,[X,i(),e("a",Z,[i("分布式锁实现"),a(l)])]),e("ul",null,[e("li",null,[e("a",$,[i("基于数据库"),a(l)])]),e("li",null,[e("a",ee,[i("基于 Redis"),a(l)]),ie]),e("li",null,[e("a",le,[i("基于 zookeeper"),a(l)])])]),e("h3",ae,[re,i(),e("a",ne,[i("分布式 ID 实现"),a(l)])]),e("ul",null,[e("li",null,[i("全局唯一ID "),e("ul",null,[e("li",null,[e("a",te,[i("UUID"),a(l)])]),e("li",null,[e("a",de,[i("数据库生成"),a(l)])]),e("li",null,[e("a",se,[i("使用redis实现"),a(l)])]),e("li",null,[e("a",he,[i("雪花算法-Snowflake"),a(l)])]),e("li",null,[e("a",oe,[i("百度-UidGenerator"),a(l)])]),e("li",null,[e("a",ce,[i("美团Leaf"),a(l)])]),e("li",null,[e("a",ue,[i("Mist 薄雾算法"),a(l)])])])])]),e("h3",Ee,[_e,i(),e("a",pe,[i("微服务组件"),a(l)])]),e("p",null,[e("a",me,[i("分布式系统知识体系"),a(l)])]),be,e("h3",fe,[ge,i(),e("a",Be,[i("接口幂等性"),a(l)])]),Ae,e("h3",ve,[xe,i(),e("a",we,[i("秒杀系统"),a(l)])]),ke,e("h3",Se,[Te,i(),e("a",Re,[i("前后端分离接口安全"),a(l)])])])}const Pe=n(h,[["render",Fe],["__file","interview.html.vue"]]);export{Pe as default};
