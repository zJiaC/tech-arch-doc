import{_ as r}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as n,o as d,c as h,a as t,b as a,d as e,e as c,f as l}from"./app-DmB7iXqf.js";const s={},o=a("h1",{id:"jvm-知识查缺补漏",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#jvm-知识查缺补漏","aria-hidden":"true"},"#"),e(" JVM 知识查缺补漏")],-1),m=l(`<h2 id="技术概括" tabindex="-1"><a class="header-anchor" href="#技术概括" aria-hidden="true">#</a> 技术概括</h2><ul><li>基于栈的指令集架构</li><li>JVM运行字节码时，所有的操作基本都是围绕两种数据结构，一种是堆栈（本质是栈结构），还有一种是队列，如果JVM执行某条指令时，该指令需要对数据进行操作，那么被操作的数据在指令执行前，必须要压到堆栈上，JVM会自动将栈顶数据作为操作数。如果堆栈上的数据需要暂时保存起来时，那么它就会被存储到局部变量队列上。</li><li>实际上我们发现，JVM执行的命令基本都是入栈出栈等，而且大部分指令都是没有操作数的，传统的汇编指令有一操作数、二操作数甚至三操作数的指令，Java相比C编译出来的汇编指令，执行起来会更加复杂，实现某个功能的指令条数也会更多，所以Java的执行效率实际上是不如C/C++的，虽然能够很方便地实现跨平台，但是性能上大打折扣，所以在性能要求比较苛刻的Android上，采用的是定制版的JVM，并且是基于寄存器的指令集架构。此外，在某些情况下，我们还可以使用JNI机制来通过Java调用C/C++编写的程序以提升性能（也就是本地方法，使用到native关键字）</li></ul><h2 id="jvm-启动流程探究" tabindex="-1"><a class="header-anchor" href="#jvm-启动流程探究" aria-hidden="true">#</a> JVM 启动流程探究</h2><p>配置JVM装载环境<br> 解析虚拟机参数<br> 设置线程栈大小<br> 执行JavaMain方法</p><h2 id="jni调用本地方法" tabindex="-1"><a class="header-anchor" href="#jni调用本地方法" aria-hidden="true">#</a> JNI调用本地方法</h2><h2 id="jvm-内存管理" tabindex="-1"><a class="header-anchor" href="#jvm-内存管理" aria-hidden="true">#</a> JVM 内存管理</h2><h3 id="内存区域划分" tabindex="-1"><a class="header-anchor" href="#内存区域划分" aria-hidden="true">#</a> 内存区域划分</h3><p><img src="https://image.itbaima.cn/markdown/2023/03/06/CP4yv1iqrfjmXzW.jpg" alt=""></p><p>我们可以看到，内存区域一共分为5个区域，其中方法区和堆是所有线程共享的区域，随着虚拟机的创建而创建，虚拟机的结束而销毁，而虚拟机栈、本地方法栈、程序计数器都是线程之间相互隔离的，每个线程都有一个自己的区域，并且线程启动时会自动创建，结束之后会自动销毁。内存划分完成之后，我们的JVM执行引擎和本地库接口，也就是Java程序开始运行之后就会根据分区合理地使用对应区域的内存了。</p><h4 id="爆内存和爆栈" tabindex="-1"><a class="header-anchor" href="#爆内存和爆栈" aria-hidden="true">#</a> 爆内存和爆栈</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-Xms最小值 -Xmx最大值 -Xss 用来设置栈容量
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以通过 IDEA 内置的 profiler 查看内存快照</p><h4 id="申请堆外内存" tabindex="-1"><a class="header-anchor" href="#申请堆外内存" aria-hidden="true">#</a> 申请堆外内存</h4><h2 id="垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#垃圾回收机制" aria-hidden="true">#</a> 垃圾回收机制</h2><h3 id="对象存活判定算法" tabindex="-1"><a class="header-anchor" href="#对象存活判定算法" aria-hidden="true">#</a> 对象存活判定算法</h3><h4 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法" aria-hidden="true">#</a> 引用计数法</h4><ul><li>每个对象都包含一个 <strong>引用计数器</strong>，用于存放引用计数（其实就是存放被引用的次数）</li><li>每当有一个地方引用此对象时，引用计数<code>+1</code></li><li>当引用失效（ 比如离开了局部变量的作用域或是引用被设定为<code>null</code>）时，引用计数<code>-1</code></li><li>当引用计数为<code>0</code>时，表示此对象不可能再被使用，因为这时我们已经没有任何方法可以得到此对象的引用了</li></ul><h4 id="可达性分析法" tabindex="-1"><a class="header-anchor" href="#可达性分析法" aria-hidden="true">#</a> 可达性分析法</h4><ul><li>位于虚拟机栈的栈帧中的本地变量表中所引用到的对象（其实就是我们方法中的局部变量）同样也包括本地方法栈中JNI引用的对象。</li><li>类的静态成员变量引用的对象。</li><li>方法区中，常量池里面引用的对象，比如我们之前提到的<code>String</code>类型对象。</li><li>被添加了锁的对象（比如synchronized关键字）</li><li>虚拟机内部需要用到的对象。</li></ul><p><img src="https://image.itbaima.cn/markdown/2023/03/06/4MIORcEDzquZFia.png" alt=""></p><h4 id="最终判定" tabindex="-1"><a class="header-anchor" href="#最终判定" aria-hidden="true">#</a> 最终判定</h4><ul><li>finalize() 垃圾回收之前执行，同一个对象的 <code>finalize()</code>方法只会有一次调用机会，也就是说，如果我们连续两次这样操作，那么第二次，对象必定被回收</li></ul><h3 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法" aria-hidden="true">#</a> 垃圾回收算法</h3><h4 id="分代收集机制" tabindex="-1"><a class="header-anchor" href="#分代收集机制" aria-hidden="true">#</a> 分代收集机制</h4><p><img src="https://image.itbaima.cn/markdown/2023/03/06/OZrKbUm39lfaAgv.png" alt=""></p><p>新的 java 版本永久代去掉变为元空间</p><h4 id="空间分配担保" tabindex="-1"><a class="header-anchor" href="#空间分配担保" aria-hidden="true">#</a> 空间分配担保</h4><p><img src="https://image.itbaima.cn/markdown/2023/03/06/71PqlEfiGgBSLae.png" alt=""></p><h4 id="标记-清除算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法" aria-hidden="true">#</a> 标记-清除算法</h4><p><img src="https://image.itbaima.cn/markdown/2023/03/06/d8anmBcLrW3iyJl.png" alt=""></p><h4 id="标记-复制算法" tabindex="-1"><a class="header-anchor" href="#标记-复制算法" aria-hidden="true">#</a> 标记-复制算法</h4><p><img src="https://image.itbaima.cn/markdown/2023/03/06/JeifGj6kmVAY2PR.png" alt=""></p><h4 id="标记-整理算法" tabindex="-1"><a class="header-anchor" href="#标记-整理算法" aria-hidden="true">#</a> 标记-整理算法</h4><p><img src="https://image.itbaima.cn/markdown/2023/03/06/4UncSVvO1P2xWKL.png" alt=""></p><h4 id="垃圾集实现" tabindex="-1"><a class="header-anchor" href="#垃圾集实现" aria-hidden="true">#</a> 垃圾集实现</h4><h5 id="garbage-first-g1-收集器" tabindex="-1"><a class="header-anchor" href="#garbage-first-g1-收集器" aria-hidden="true">#</a> Garbage First (G1) 收集器</h5><p><img src="https://image.itbaima.cn/markdown/2023/03/06/kXRMlt5iFDvjq8y.png" alt=""></p><p>分为以下四个步骤：</p><ul><li>初始标记（暂停用户线程）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li><li>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象。</li><li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。</li></ul><h4 id="元空间" tabindex="-1"><a class="header-anchor" href="#元空间" aria-hidden="true">#</a> 元空间</h4><p><img src="https://image.itbaima.cn/markdown/2023/03/06/2RD3AnPvbh1lQ5N.png" alt=""></p><h4 id="引用类型" tabindex="-1"><a class="header-anchor" href="#引用类型" aria-hidden="true">#</a> 引用类型</h4><ul><li><strong>强引用 (Strongly Reference)</strong> ：最传统的引用，如 <code>Object obj = new Object()</code> 。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li><strong>软引用 (Soft Reference)</strong> ：用于描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会被列入回收范围内进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li><strong>弱引用 (Weak Reference)</strong> ：用于描述那些非必须的对象，强度比软引用弱。被弱引用关联对象只能生存到下一次垃圾收集发生时，无论当前内存是否足够，弱引用对象都会被回收。</li><li><strong>虚引用 (Phantom Reference)</strong> ：最弱的引用关系。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时收到一个系统通知。</li></ul><h2 id="类与类加载" tabindex="-1"><a class="header-anchor" href="#类与类加载" aria-hidden="true">#</a> 类与类加载</h2><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>`,45),g={href:"https://www.itbaima.cn/document/1/2/0",target:"_blank",rel:"noopener noreferrer"};function p(u,b){const i=n("ExternalLinkIcon");return d(),h("div",null,[o,t(" more "),m,a("p",null,[a("a",g,[e("Java JVM 虚拟机"),c(i)])])])}const v=r(s,[["render",p],["__file","jvm.html.vue"]]);export{v as default};
