import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as s,f as t,d as e,o as l}from"./app-X9Qm7P3-.js";const r="/tech-arch-doc/images/%E5%8D%95%E9%93%BE%E8%A1%A8.png",h="/tech-arch-doc/images/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png",p="/tech-arch-doc/images/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png",k="/tech-arch-doc/images/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png",d="/tech-arch-doc/images/ArrayList%E3%80%81LinkedList%EF%BC%8C%E5%A4%B4%E6%8F%92%E7%BB%93%E6%9E%84.png",c="/tech-arch-doc/images/ArrayList%E3%80%81LinkedList%EF%BC%8C%E5%A4%B4%E6%8F%92%E5%AF%B9%E6%AF%94.png",A="/tech-arch-doc/images/ArrayList%E3%80%81LinkedList%EF%BC%8C%E5%B0%BE%E6%8F%92%E7%BB%93%E6%9E%84.png",E="/tech-arch-doc/images/ArrayList%E3%80%81LinkedList%EF%BC%8C%E5%B0%BE%E6%8F%92%E5%AF%B9%E6%AF%94.png",g="/tech-arch-doc/images/ArrayList%E3%80%81LinkedList%EF%BC%8C%E4%B8%AD%E9%97%B4%E6%8F%92%E7%BB%93%E6%9E%84.png",o="/tech-arch-doc/images/ArrayList%E3%80%81LinkedList%EF%BC%8C%E4%B8%AD%E9%97%B4%E6%8F%92%E5%AF%B9%E6%AF%94.png",y={};function B(m,i){return l(),n("div",null,[i[0]||(i[0]=s("h1",{id:"线性数据结构相关",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#线性数据结构相关"},[s("span",null,"线性数据结构相关")])],-1)),i[1]||(i[1]=s("p",null,[s("a",{href:"https://visualgo.net/zh",target:"_blank",rel:"noopener noreferrer"},"数据结构和算法动态可视化 (Chinese)")],-1)),t(" more "),i[2]||(i[2]=e('<h2 id="链表-link-list" tabindex="-1"><a class="header-anchor" href="#链表-link-list"><span>链表 Link List</span></a></h2><p>在计算机科学中，链表是数据元素的线性集合，元素的线性顺序不是由它们在内存中的物理地址给出的。它是由一组节点组成的数据结构，每个元素指向下一个元素，这些节点一起，表示线性序列。</p><h3 id="描述一下链表的数据结构" tabindex="-1"><a class="header-anchor" href="#描述一下链表的数据结构"><span>描述一下链表的数据结构？</span></a></h3><p><img src="'+r+'" alt="单链表"><br><img src="'+h+'" alt="循环链表"><br><img src="'+p+'" alt="双向链表"><br><img src="'+k+`" alt="双向链表"></p><h3 id="java-中-linkedlist-使用的是单向链表、双向链表还是循环链表" tabindex="-1"><a class="header-anchor" href="#java-中-linkedlist-使用的是单向链表、双向链表还是循环链表"><span>Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？</span></a></h3><ul><li>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul><h3 id="链表中数据的插入、删除、获取元素-时间复杂度是多少" tabindex="-1"><a class="header-anchor" href="#链表中数据的插入、删除、获取元素-时间复杂度是多少"><span>链表中数据的插入、删除、获取元素，时间复杂度是多少？</span></a></h3><ul><li>单向链表要删除某一节点时，必须要先通过遍历的方式找到前驱节点（通过待删除节点序号或按值查找）。若仅仅知道待删除节点，是不能知道前驱节点的，故单链表的增删操作复杂度为O(n)。</li><li>双链表（双向链表）知道要删除某一节点p时，获取其前驱节点q的方式为 q = p-&gt;prior，不必再进行遍历。故时间复杂度为O(1)。而若只知道待删除节点的序号，则依然要按序查找，时间复杂度仍为O(n)。</li><li>单、双链表的插入操作，若给定前驱节点，则时间复杂度均为O(1)。否则只能按序或按值查找前驱节点，时间复杂度为O(n)。</li><li>至于查找，二者的时间复杂度均为O(n)。 对于最基本的CRUD操作，双链表优势在于删除给定节点。但其劣势在于浪费存储空间（若从工程角度考量，则其维护性和可读性都更低）。</li></ul><p>双链表本身的结构优势在于，可以O(1)地找到前驱节点，若算法需要对待操作节点的前驱节点做处理，则双链表相比单链表有更加便捷的优势。<br><a href="https://bugstack.cn/md/java/interview/2020-08-30-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C%20%C2%B7%20%E7%AC%AC8%E7%AF%87%E3%80%8ALinkedList%E6%8F%92%E5%85%A5%E9%80%9F%E5%BA%A6%E6%AF%94ArrayList%E5%BF%AB%EF%BC%9F%E4%BD%A0%E7%A1%AE%E5%AE%9A%E5%90%97%EF%BC%9F%E3%80%8B.html" target="_blank" rel="noopener noreferrer">LinkedList插入速度比ArrayList快？你确定吗？</a></p><h2 id="数组-array" tabindex="-1"><a class="header-anchor" href="#数组-array"><span>数组 Array</span></a></h2><p>数组只是个名称，它可以描述一组操作，也可以命名这组操作。数组的数据操作，是通过 idx-&gt;val 的方式来处理。它不是具体要求内存上要存储着连续的数据才叫数组，而是说，通过连续的索引 idx，也可以线性访问相邻的数据。</p><h3 id="数组的元素删除和获取-时间复杂度是多少" tabindex="-1"><a class="header-anchor" href="#数组的元素删除和获取-时间复杂度是多少"><span>数组的元素删除和获取，时间复杂度是多少？</span></a></h3><ul><li>因为数组的元素在内存中都是连续的，在访问其中元素的时候，会根据元素的下标相对于第一个下标的距离直接访问内存，所以访问任意元素的时间复杂度为O(1)，不与数组下标大小有关联，所以说它的随机存取的速度非常快。改数组其中的元素其实也是访问数组的下标，更改内存地址存放的内容，其复杂度是一样的。</li><li>查的时候说了数组存取非常快，在数组的增加元素的时候，看复杂度的时候要看元素插入的位置。自己在前面文章时候偷懒了，只在Goalng的切片后面加元素，不用动其他的元素，这是最乐观的情况，所以在数组后面添加元素的时候，时间最好复杂度<br> 为O(1)，如果在数组最前面添加元素的话，后面元素在内存中存放的位置都要往后挪一位，此时要操作所有的元素，此时为最坏复杂度<br> ：O(n)，如果要看平均复杂度<br> 的话，那么就要遍历数组插入的所有插入位置的可能，然后把所有的复杂度相加再除以所有的可能的数量，那么假如数组长度为N,复杂度就是（1+2+3+...+n）/n=&gt;n/2,然后忽略常数部分，数组增加元素平均复杂度<br> 就是O(n)</li><li>删除和增加元素一样，删除数组第一个元素，后面所有的元素都要移动内存地址，复杂度为O(n)，删除最后一个元素，就只操作数组中的一个元素，此时复杂度是最好复杂度<br> ：O(1),平均复杂度<br> 为O(n)。</li></ul><h3 id="arraylist-中默认的初始化长度是多少" tabindex="-1"><a class="header-anchor" href="#arraylist-中默认的初始化长度是多少"><span>ArrayList 中默认的初始化长度是多少？</span></a></h3><p>ArrayList 底层是数组 elementData，用于存放插入的数据。初始大小是 0，当有数据插入时，默认大小 DEFAULT_CAPACITY = 10。</p><h3 id="arraylist-中扩容的范围是多大一次" tabindex="-1"><a class="header-anchor" href="#arraylist-中扩容的范围是多大一次"><span>ArrayList 中扩容的范围是多大一次？</span></a></h3><p>新数组容量为旧数组的 1.5 倍：newCapacity = 1.5 * oldCapacity ，并且将旧数组内容通过 Array.copyOf 全部复制到新数组。此时，size 还未真正 +1，新旧数组长度（size 一致），不过容量不同。</p><h3 id="arraylist-是如何完成扩容的-system-arraycopy-各个入参的作用是什么" tabindex="-1"><a class="header-anchor" href="#arraylist-是如何完成扩容的-system-arraycopy-各个入参的作用是什么"><span>ArrayList 是如何完成扩容的，System.arraycopy 各个入参的作用是什么？</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">E</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> e) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 确保内部容量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> minCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> size </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (elementData </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        minCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">max</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(DEFAULT_CAPACITY, minCapacity);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 判断扩容操作</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (minCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> elementData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> oldCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> elementData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> newCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> oldCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (oldCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (newCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> minCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            newCapacity </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> minCapacity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        elementData </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Arrays</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">copyOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(elementData, newCapacity);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 添加元素</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    elementData[size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="什么场景下使用数组或链表更合适" tabindex="-1"><a class="header-anchor" href="#什么场景下使用数组或链表更合适"><span>什么场景下使用数组或链表更合适？</span></a></h2><ul><li>对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线性表。<br><img src="`+d+'" alt=""><br><img src="'+c+'" alt=""><br><img src="'+A+'" alt=""><br><img src="'+E+'" alt=""><br><img src="'+g+'" alt=""><br><img src="'+o+'" alt=""></li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>ArrayList与LinkedList都有自己的使用场景，如果你不能很好的确定，那么就使用ArrayList。但如果你能确定你会在集合的首位有大量的插入、删除以及获取操作，那么可以使用LinkedList，因为它都有相应的方法；addFirst、addLast、removeFirst、removeLast、getFirst、getLast，这些操作的时间复杂度都是O(1)，非常高效。</li><li>LinkedList的链表结构不一定会比ArrayList节省空间，首先它所占用的内存不是连续的，其次他还需要大量的实例化对象创造节点。虽然不一定节省空间，但链表结构也是非常优秀的数据结构，它能在你的程序设计中起着非常优秀的作用，例如可视化的链路追踪图，就是需要链表结构，并需要每个节点自旋一次，用于串联业务。</li><li>程序的精髓往往就是数据结构的设计，这能为你的程序开发提供出非常高的效率改变。可能目前你还不能用到，但万一有一天你需要去造🚀火箭了呢？</li></ul><h1 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h1><p><a href="https://bugstack.cn/md/algorithm/data-structures/2022-07-22-linked-list.html" target="_blank" rel="noopener noreferrer">数组和链表</a></p><p><a href="https://bugstack.cn/md/algorithm/data-structures/2022-07-22-linked-list.html" target="_blank" rel="noopener noreferrer">数据结构：链表 Link List</a></p><p><a href="https://www.pdai.tech/md/java/collection/java-collection-LinkedList.html" target="_blank" rel="noopener noreferrer">java-collection-LinkedList</a></p><p><a href="https://blog.csdn.net/weixin_43338519/article/details/107577687" target="_blank" rel="noopener noreferrer">链表的插入、删除、查找时间复杂度</a></p><p><a href="https://blog.csdn.net/m0_37135421/article/details/80964378" target="_blank" rel="noopener noreferrer">数组和链表分别比较适合用于什么场景</a></p><p><a href="https://bugstack.cn/md/java/interview/2020-08-30-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C%20%C2%B7%20%E7%AC%AC8%E7%AF%87%E3%80%8ALinkedList%E6%8F%92%E5%85%A5%E9%80%9F%E5%BA%A6%E6%AF%94ArrayList%E5%BF%AB%EF%BC%9F%E4%BD%A0%E7%A1%AE%E5%AE%9A%E5%90%97%EF%BC%9F%E3%80%8B.html" target="_blank" rel="noopener noreferrer">LinkedList插入速度比ArrayList快？你确定吗？</a></p><p><a href="https://www.modb.pro/db/166034" target="_blank" rel="noopener noreferrer">动态数组和链表的增删改查的时间复杂度对比</a></p><p><a href="https://www.cnblogs.com/ideal-20/p/14380633.html" target="_blank" rel="noopener noreferrer">Java ArrayList源码分析（含扩容机制等重点问题分析）</a></p>',32))])}const F=a(y,[["render",B]]),v=JSON.parse('{"path":"/posts/interview/linear-data-structures.html","title":"线性数据结构相关","lang":"zh-CN","frontmatter":{"icon":"lock","date":"2023-02-27T00:00:00.000Z","category":["面试"],"tag":["数据结构","Java"],"feed":false,"seo":false,"head":[]},"git":{"createdTime":1677736458000,"updatedTime":1677736458000,"contributors":[{"name":"zJiaC","username":"zJiaC","email":"425226133@qq.com","commits":1,"url":"https://github.com/zJiaC"}]},"readingTime":{"minutes":6.79,"words":2038},"filePathRelative":"posts/interview/linear-data-structures.md"}');export{F as comp,v as data};
